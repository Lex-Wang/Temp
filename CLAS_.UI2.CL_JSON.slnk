<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="/UI2/CL_JSON" VERSION="1" LANGU="1" DESCRIPT="JSON converter" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="T_S_SYMBOL" VERSION="1" LANGU="1" DESCRIPT="Helper type for structure fields iteration" EXPOSURE="1" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="22 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF t_s_symbol,
        header TYPE string,
        name            TYPE string,
        type   TYPE REF TO cl_abap_datadescr,
        value           TYPE REF TO data,
        compressable    TYPE abap_bool,
        read_only       TYPE abap_bool,
      END OF t_s_symbol
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="T_T_SYMBOL" VERSION="1" LANGU="1" DESCRIPT="Standard table of T_S_SYMBOL" EXPOSURE="1" STATE="1" EDITORDER="8 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="64 " TYPESRC_LENG="0 " TYPESRC="t_t_symbol TYPE STANDARD TABLE OF t_s_symbol WITH DEFAULT KEY
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="T_S_FIELD_CACHE" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="9 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="27 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF t_s_field_cache,
        name  TYPE string,
        type  TYPE REF TO cl_abap_datadescr,
        value TYPE REF TO data,
      END OF t_s_field_cache
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="T_T_FIELD_CACHE" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="10 " TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="76 " TYPESRC_LENG="0 " TYPESRC="t_t_field_cache TYPE HASHED TABLE OF t_s_field_cache WITH UNIQUE KEY name
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="NAME_MAPPINGS_EX" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="11 " TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="23 " SRCCOLUMN2="74 " TYPESRC_LENG="0 " TYPESRC="name_mappings_ex TYPE HASHED TABLE OF name_mapping WITH UNIQUE KEY json
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="JSON" VERSION="1" LANGU="1" DESCRIPT="JSON string" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="NAME_MAPPING" VERSION="1" LANGU="1" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="29 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF name_mapping,
            abap  TYPE abap_compname,
            json  TYPE string,
           END OF name_mapping
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="NAME_MAPPINGS" VERSION="1" LANGU="1" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping Table" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="4 " SRCROW2="22 " SRCCOLUMN2="71 " TYPESRC_LENG="0 " TYPESRC="name_mappings TYPE HASHED TABLE OF name_mapping WITH UNIQUE KEY abap
"/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="BOOL" VERSION="1" LANGU="1" DESCRIPT="2 state boolean type (&apos;X&apos; - true, &apos;&apos; - false), as abap_bool" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="TRIBOOL" VERSION="1" LANGU="1" DESCRIPT="3 state boolean type (&apos;X&apos;-true, &apos;-&apos;-false, &apos;&apos;-undefined)" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <types CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME_MODE" VERSION="1" LANGU="1" DESCRIPT="Name conversion mode" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes

DEFINE escape_json_inplace.
*  replace all occurrences of regex `[\\&quot;]` in &amp;1 with `\\$0`. &lt;-- this is slower than 2 plain replaces
  replace all occurrences of `\` in &amp;1 with `\\`.
  replace all occurrences of `&quot;` in &amp;1 with `\&quot;`.
END-OF-DEFINITION.

DEFINE escape_json.
  move &amp;1 to &amp;2.
  escape_json_inplace &amp;2.
END-OF-DEFINITION.

DEFINE is_compressable.
  IF mv_extended IS INITIAL.
    &amp;3 = abap_true.
  ELSE.
    &amp;3 = is_compressable( type_descr = &amp;1 name = &amp;2 ).
  ENDIF.
END-OF-DEFINITION.

DEFINE dump_type.
  IF mv_extended IS INITIAL.
    dump_type_int &amp;1 &amp;2 &amp;3.
  ELSE.
    &amp;3 = dump_type( data = &amp;1 type_descr = &amp;2 ).
  ENDIF.
END-OF-DEFINITION.

DEFINE dump_type_int.

  case &amp;2-&gt;type_kind.
    when cl_abap_typedescr=&gt;typekind_float or cl_abap_typedescr=&gt;typekind_int or cl_abap_typedescr=&gt;typekind_int1 or
         cl_abap_typedescr=&gt;typekind_int2 or cl_abap_typedescr=&gt;typekind_packed or `8`. &quot; TYPEKIND_INT8 -&gt; &apos;8&apos; only from 7.40.
      if &amp;2-&gt;type_kind eq cl_abap_typedescr=&gt;typekind_packed and mv_ts_as_iso8601 eq c_bool-true and &amp;2-&gt;absolute_name cp `\TYPE=TIMESTAMP*`.
        if &amp;1 is initial.
          &amp;3 = `&quot;&quot;`.
        else.
          move &amp;1 to &amp;3.
          if &amp;2-&gt;absolute_name eq `\TYPE=TIMESTAMP`.
            concatenate `&quot;` &amp;3(4) `-` &amp;3+4(2) `-` &amp;3+6(2) `T` &amp;3+8(2) `:` &amp;3+10(2) `:` &amp;3+12(2) `.0000000Z&quot;`  into &amp;3.
          elseif &amp;2-&gt;absolute_name eq `\TYPE=TIMESTAMPL`.
            concatenate `&quot;` &amp;3(4) `-` &amp;3+4(2) `-` &amp;3+6(2) `T` &amp;3+8(2) `:` &amp;3+10(2) `:` &amp;3+12(2) `.` &amp;3+15(7) `Z&quot;`  into &amp;3.
          endif.
        endif.
      elseif &amp;1 is initial.
        &amp;3 = `0`.
      else.
        move &amp;1 to &amp;3.
        if &amp;1 lt 0.
          if &amp;2-&gt;type_kind &lt;&gt; cl_abap_typedescr=&gt;typekind_float. &quot;float: sign is already at the beginning
            shift &amp;3 right circular.
          endif.
        else.
          condense &amp;3.
        endif.
      endif.
    when cl_abap_typedescr=&gt;typekind_num.
      if mv_numc_as_string eq abap_true.
        if &amp;1 is initial.
          &amp;3 = `&quot;&quot;`.
        else.
          concatenate `&quot;` &amp;1 `&quot;` into &amp;3.
        endif.
      else.
        if &amp;1 is initial.
        &amp;3 = `0`.
      else.
        move &amp;1 to &amp;3.
        shift &amp;3 left deleting leading ` 0`.
        endif.
      endif.
    when cl_abap_typedescr=&gt;typekind_string or cl_abap_typedescr=&gt;typekind_csequence or cl_abap_typedescr=&gt;typekind_clike.
      if &amp;1 is initial.
        &amp;3 = `&quot;&quot;`.
      elseif &amp;2-&gt;absolute_name eq mc_json_type.
        &amp;3 = &amp;1.
      else.
        escape_json &amp;1 &amp;3.
        concatenate `&quot;` &amp;3 `&quot;` into &amp;3.
      endif.
    when cl_abap_typedescr=&gt;typekind_xstring or cl_abap_typedescr=&gt;typekind_hex.
      if &amp;1 is initial.
        &amp;3 = `&quot;&quot;`.
      else.
        &amp;3 = xstring_to_string( &amp;1 ).
        escape_json_inplace &amp;3.
        concatenate `&quot;` &amp;3 `&quot;` into &amp;3.
      endif.
    when cl_abap_typedescr=&gt;typekind_char.
      if &amp;2-&gt;output_length eq 1 and mc_bool_types cs &amp;2-&gt;absolute_name.
        if &amp;1 eq c_bool-true.
          &amp;3 = `true`.                                      &quot;#EC NOTEXT
        elseif mc_bool_3state cs &amp;2-&gt;absolute_name and &amp;1 is initial.
          &amp;3 = `null`.                                      &quot;#EC NOTEXT
        else.
          &amp;3 = `false`.                                     &quot;#EC NOTEXT
        endif.
      else.
        escape_json &amp;1 &amp;3.
        concatenate `&quot;` &amp;3 `&quot;` into &amp;3.
      endif.
    when cl_abap_typedescr=&gt;typekind_date.
      concatenate `&quot;` &amp;1(4) `-` &amp;1+4(2) `-` &amp;1+6(2) `&quot;` into &amp;3.
    when cl_abap_typedescr=&gt;typekind_time.
      concatenate `&quot;` &amp;1(2) `:` &amp;1+2(2) `:` &amp;1+4(2) `&quot;` into &amp;3.
    when others.
      if &amp;1 is initial.
        &amp;3 = `null`.                                        &quot;#EC NOTEXT
      else.
        move &amp;1 to &amp;3.
      endif.
  endcase.

END-OF-DEFINITION.

DEFINE format_name.
  case &amp;2.
    when pretty_mode-camel_case.
      &amp;3 = pretty_name( &amp;1 ).
    when pretty_mode-extended.
      &amp;3 = pretty_name_ex( &amp;1 ).
    when pretty_mode-user_low_case.
      read table mt_name_mappings with table key abap = &amp;1 assigning &lt;cache&gt;.
      if sy-subrc is initial.
        &amp;3 = &lt;cache&gt;-json.
      else.
        &amp;3 = &amp;1.
        translate &amp;3 to lower case.                       &quot;#EC SYNTCHAR
      endif.
    when pretty_mode-user.
      read table mt_name_mappings with table key abap = &amp;1 assigning &lt;cache&gt;.
      if sy-subrc is initial.
        &amp;3 = &lt;cache&gt;-json.
      else.
        &amp;3 = &amp;1.
      endif.
    when pretty_mode-low_case.
      &amp;3 = &amp;1.
      translate &amp;3 to lower case.                         &quot;#EC SYNTCHAR
    when others.
      &amp;3 = &amp;1.
  endcase.
END-OF-DEFINITION.

DEFINE throw_error.
  raise exception type cx_sy_move_cast_error.
END-OF-DEFINITION.

DEFINE while_offset_cs.
*  &gt;= 7.02 alternative
*  pos = find_any_not_of( val = json sub = &amp;1 off = offset ).
*  if pos eq -1. offset = length.
*  else. offset = pos. endif.

* &lt; 7.02
  while offset &lt; length.
    find first occurrence of json+offset(1) in &amp;1.
    if sy-subrc is not initial.
      exit.
    endif.
    offset = offset + 1.
  endwhile.
* &lt; 7.02

END-OF-DEFINITION.


DEFINE eat_white.
  while_offset_cs sv_white_space.
END-OF-DEFINITION.

DEFINE eat_string.
  if json+offset(1) eq `&quot;`.
    mark   = offset + 1.
    offset = mark.
    do.
      find first occurrence of `&quot;` in section offset offset of json match offset pos.
      if sy-subrc is not initial.
        throw_error.
      endif.
        offset = pos.
        pos = pos - 1.
        &quot; if escaped search further
        while pos ge 0 and json+pos(1) eq `\`.
          pos = pos - 1.
        endwhile.
      match = ( offset - pos ) mod 2.
      if match ne 0.
        exit.
      endif.
      offset = offset + 1.
    enddo.
    match = offset - mark.
    &amp;1 = json+mark(match).
    &quot; unescaped singe characters, e.g \\, \&quot;, \/ etc
    replace all occurrences of regex `\\(.)` in &amp;1 with `$1`.
    offset = offset + 1.
  else.
    throw_error.
  endif.
END-OF-DEFINITION.

DEFINE eat_number.
  mark   = offset.
  while_offset_cs `0123456789+-eE.`.                        &quot;#EC NOTEXT
  match = offset - mark.
  &amp;1 = json+mark(match).
END-OF-DEFINITION.

DEFINE eat_bool.
  mark   = offset.
  while_offset_cs `aeflnrstu`.                              &quot;#EC NOTEXT
  match = offset - mark.
  if json+mark(match) eq `true`.                            &quot;#EC NOTEXT
    &amp;1 = c_bool-true.
  elseif json+mark(match) eq `false`.                       &quot;#EC NOTEXT
    if type_descr is bound and mc_bool_3state cs type_descr-&gt;absolute_name.
      &amp;1 = c_tribool-false.
    else.
      &amp;1 = c_bool-false.
    endif.
  elseif json+mark(match) eq `null`.                        &quot;#EC NOTEXT
    clear &amp;1.
  endif.
END-OF-DEFINITION.

DEFINE eat_char.
  if offset &lt; length and json+offset(1) eq &amp;1.
    offset = offset + 1.
  else.
    throw_error.
  endif.
END-OF-DEFINITION.</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <localTestClasses>*----------------------------------------------------------------------*
*       CLASS lcl_test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test DEFINITION FINAL.
  PUBLIC SECTION.
    DATA: id TYPE i.
    DATA: children TYPE STANDARD TABLE OF REF TO lcl_test.
ENDCLASS.                    &quot;lcl_test DEFINITION

*----------------------------------------------------------------------*
*       CLASS lc_json_custom DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lc_json_custom DEFINITION FINAL INHERITING FROM /ui2/cl_json.
  PUBLIC SECTION.
    CLASS-METHODS:
      class_constructor,
      serialize_ex IMPORTING data          TYPE data
                             compress      TYPE bool DEFAULT c_bool-false
                             pretty_name   TYPE pretty_name_mode DEFAULT pretty_mode-none
                   RETURNING VALUE(r_json) TYPE json,
      deserialize_ex IMPORTING json        TYPE json OPTIONAL
                               pretty_name TYPE pretty_name_mode DEFAULT pretty_mode-none
                     CHANGING  data        TYPE data.

  PROTECTED SECTION.
    METHODS:
      is_compressable REDEFINITION,
      pretty_name_ex REDEFINITION.
ENDCLASS.                    &quot;lc_json_custom DEFINITION

*----------------------------------------------------------------------*
*       CLASS lc_json_custom IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lc_json_custom IMPLEMENTATION.

  METHOD class_constructor.
    CONCATENATE mc_bool_types `\TYPE=/UI2/BOOLEAN` INTO mc_bool_types.
  ENDMETHOD.                    &quot;class_constructor

  METHOD serialize_ex.
    DATA: lo_json  TYPE REF TO lc_json_custom.
    CREATE OBJECT lo_json
      EXPORTING
        compress         = compress
        pretty_name      = pretty_name
        assoc_arrays     = abap_true
        assoc_arrays_opt = abap_true
        expand_includes  = abap_true
        numc_as_string   = abap_true
        ts_as_iso8601    = abap_true.
    r_json = lo_json-&gt;serialize_int( data = data ).
  ENDMETHOD.                    &quot;serialize_ex

  METHOD deserialize_ex.
    DATA: lo_json TYPE REF TO lc_json_custom.
    IF json IS NOT INITIAL.
      CREATE OBJECT lo_json
        EXPORTING
          pretty_name      = pretty_name
          assoc_arrays     = abap_true
          assoc_arrays_opt = abap_true.
      TRY .
          lo_json-&gt;deserialize_int( EXPORTING json = json CHANGING data = data ).
        CATCH cx_sy_move_cast_error.
      ENDTRY.
    ENDIF.
  ENDMETHOD.                    &quot;deserialize_ex

  METHOD is_compressable.
    IF type_descr-&gt;absolute_name EQ `\TYPE=STRING` OR name EQ `INITIAL`.
      rv_compress = abap_false.
    ELSE.
      rv_compress = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;is_compressable

  METHOD pretty_name_ex.
    out = super-&gt;pretty_name_ex( in ).
    CONCATENATE out &apos;Xxx&apos; INTO out.
  ENDMETHOD.                    &quot;pretty_name

ENDCLASS.                    &quot;lc_json_custom IMPLEMENTATION

* ----------------------------------------------------------------------
CLASS abap_unit_testclass DEFINITION FOR TESTING FINAL &quot;#AU Duration Medium
  &quot;#AU Risk_Level Harmless
.
  PRIVATE SECTION.

    METHODS: abap_to_json_simple_transform IMPORTING data           TYPE any
                                           RETURNING VALUE(rv_json) TYPE string.

    METHODS: deserialize_form_factor FOR TESTING.
    METHODS: deserialize_target_mapping FOR TESTING.
    METHODS: deserialize_array FOR TESTING.
    METHODS: deserialize_malformed FOR TESTING.
    METHODS: deserialize_malformed_type FOR TESTING.
    METHODS: deserialize_non_fitting_table FOR TESTING.
    METHODS: serialize_form_factor FOR TESTING.
    METHODS: serialize_table FOR TESTING.
    METHODS: serialize_numbers FOR TESTING.
    METHODS: serialize_associative_array FOR TESTING.
    METHODS: serialize_types FOR TESTING.
    METHODS: serialize_booleans FOR TESTING.
    METHODS: serialize_ref FOR TESTING.
    METHODS: serialize_upper_camel_case FOR TESTING.
    METHODS: deserialize_camel_case FOR TESTING.
    METHODS: serialize_included_types FOR TESTING.
    METHODS: deserialize_ref FOR TESTING.
    METHODS: deserialize_types FOR TESTING.
    METHODS: deserialize_news FOR TESTING.
    METHODS: deserialize_dynamic_tile FOR TESTING.
    METHODS: deserialize_associative_array FOR TESTING.
    METHODS: deserialize_array_table_line FOR TESTING.
    METHODS: deserialize_empty_structure FOR TESTING.
    METHODS: serialize_recursive FOR TESTING.
    METHODS: serialize_object FOR TESTING.
    METHODS: deserialize_object FOR TESTING.
    METHODS: deserialize_alias_type FOR TESTING.
    METHODS: deserialize_partial FOR TESTING.
    METHODS: serialize_partial FOR TESTING.
    METHODS: serialize_dynamic_type FOR TESTING.
    METHODS: custom_compressible FOR TESTING.
    METHODS: custom_pretty_name FOR TESTING.
    METHODS: custom_pretty_name2 FOR TESTING.
    METHODS: extended_pretty_name FOR TESTING.
    METHODS: name_value_map FOR TESTING.
    METHODS: dynamic_types FOR TESTING.
    METHODS: deserialze_to_read_only FOR TESTING.
    METHODS: generate FOR TESTING.
    METHODS: generate_for_odata FOR TESTING.
    METHODS: deserialize_odata FOR TESTING.
    METHODS: initialize_on_deserialize FOR TESTING.
    METHODS: deserialize_ref_to_data FOR TESTING.

ENDCLASS.       &quot;abap_unit_testclass
* ----------------------------------------------------------------------
CLASS abap_unit_testclass IMPLEMENTATION.

  METHOD serialize_numbers.
    TYPES:
      BEGIN OF t_root,
        negative_i TYPE i,
        positive_i TYPE i,
        positive_n TYPE n LENGTH 6,
        negative_f TYPE f,
        positive_b TYPE int1,
        negative_s TYPE int2,
        negative_p TYPE p LENGTH 16 DECIMALS 12,
      END OF t_root.

    DATA: ls_data TYPE t_root,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    ls_data-negative_i = -1.
    ls_data-positive_i = 10000.
    ls_data-positive_n = 1.
    ls_data-negative_f = &apos;-1.7976931348623158E+30&apos;.
    ls_data-positive_b = 255.
    ls_data-negative_s = -32768.
    ls_data-negative_p = &apos;-2343.342454332245&apos;.

    lv_exp = &apos;{&quot;NEGATIVE_I&quot;:-1,&quot;POSITIVE_I&quot;:10000,&quot;POSITIVE_N&quot;:1,&quot;NEGATIVE_F&quot;:-1.7976931348623158E+30,&quot;POSITIVE_B&quot;:255,&quot;NEGATIVE_S&quot;:-32768,&quot;NEGATIVE_P&quot;:-2343.342454332245}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of numeric types fails&apos; ).

    lv_exp = &apos;{&quot;NEGATIVE_I&quot;:-1,&quot;POSITIVE_I&quot;:10000,&quot;POSITIVE_N&quot;:&quot;000001&quot;,&quot;NEGATIVE_F&quot;:-1.7976931348623158E+30,&quot;POSITIVE_B&quot;:255,&quot;NEGATIVE_S&quot;:-32768,&quot;NEGATIVE_P&quot;:-2343.342454332245}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data numc_as_string = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of numeric types fails&apos; ).

    lv_exp = &apos;{&quot;negative_i&quot;:-1,&quot;positive_i&quot;:10000,&quot;positive_n&quot;:1,&quot;negative_f&quot;:-1.7976931348623158E+30,&quot;positive_b&quot;:255,&quot;negative_s&quot;:-32768,&quot;negative_p&quot;:-2343.342454332245}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = /ui2/cl_json=&gt;pretty_mode-low_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Low case name prety printing fails&apos; ).

  ENDMETHOD.                    &quot;serialize_numbers

  METHOD serialize_booleans.

    TYPES:
      BEGIN OF t_data,
        bool_true           TYPE abap_bool,
        bool_false          TYPE abap_bool,
        tribool_true        TYPE boolean,
        tribool_false       TYPE boolean,
        tribool_undefined   TYPE boolean,
        x_bool_true         TYPE /ui2/cl_json=&gt;bool,
        x_bool_false        TYPE /ui2/cl_json=&gt;bool,
        x_tribool_true      TYPE /ui2/cl_json=&gt;tribool,
        x_tribool_false     TYPE /ui2/cl_json=&gt;tribool,
        x_tribool_undefined TYPE /ui2/cl_json=&gt;tribool,
      END OF t_data.

    DATA: ls_data TYPE t_data,
          lv_act  TYPE string,
          ls_act  TYPE t_data,
          lv_exp  LIKE lv_act.

    ls_data-bool_true           = abap_true.
    ls_data-bool_false          = abap_false.
    ls_data-tribool_true        = /ui2/cl_json=&gt;c_tribool-true.
    ls_data-tribool_false       = /ui2/cl_json=&gt;c_tribool-false.
    ls_data-tribool_undefined   = /ui2/cl_json=&gt;c_tribool-undefined.
    ls_data-x_bool_true         = /ui2/cl_json=&gt;c_bool-true.
    ls_data-x_bool_false        = /ui2/cl_json=&gt;c_bool-false.
    ls_data-x_tribool_true      = /ui2/cl_json=&gt;c_tribool-true.
    ls_data-x_tribool_false     = /ui2/cl_json=&gt;c_tribool-false.
    ls_data-x_tribool_undefined = /ui2/cl_json=&gt;c_tribool-undefined.

    lv_exp = &apos;{&quot;BOOL_TRUE&quot;:true,&quot;BOOL_FALSE&quot;:false,&quot;TRIBOOL_TRUE&quot;:true,&quot;TRIBOOL_FALSE&quot;:false,&quot;TRIBOOL_UNDEFINED&quot;:null,&quot;X_BOOL_TRUE&quot;:true,&quot;X_BOOL_FALSE&quot;:false,&quot;X_TRIBOOL_TRUE&quot;:true,&quot;X_TRIBOOL_FALSE&quot;:false,&quot;X_TRIBOOL_UNDEFINED&quot;:null}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of boolean types fails&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_data msg = &apos;Deserialization of boolean types fails&apos; ).

    lv_exp = &apos;{&quot;BOOL_TRUE&quot;:true,&quot;TRIBOOL_TRUE&quot;:true,&quot;TRIBOOL_FALSE&quot;:false,&quot;X_BOOL_TRUE&quot;:true,&quot;X_TRIBOOL_TRUE&quot;:true,&quot;X_TRIBOOL_FALSE&quot;:false}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data compress = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Compressed serialization of boolean types fails&apos; ).

    CLEAR ls_act.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_data msg = &apos;Deserialization of compressed boolean types fails&apos; ).

  ENDMETHOD.                    &quot;serialize_booleans

  METHOD abap_to_json_simple_transform.

    &quot;&quot;&quot; CODE BELOW ONLY FOR 7.31 and higher &quot;&quot;&quot;

    DATA: lo_writer        TYPE REF TO cl_sxml_string_writer,
          lv_output_length TYPE i,
          lt_binary_tab    TYPE STANDARD TABLE OF sdokcntbin,
          lv_jsonx         TYPE xstring.

    FIELD-SYMBOLS: &lt;xt_json&gt; TYPE i.

    ASSIGN (&apos;IF_SXML=&gt;CO_XT_JSON&apos;) TO &lt;xt_json&gt;.
    IF &lt;xt_json&gt; IS ASSIGNED.

      lo_writer = cl_sxml_string_writer=&gt;create( type = &lt;xt_json&gt; ).

      CALL TRANSFORMATION id SOURCE text = data RESULT XML lo_writer.

      lv_jsonx = lo_writer-&gt;get_output( ).
      CALL FUNCTION &apos;SCMS_XSTRING_TO_BINARY&apos;
        EXPORTING
          buffer        = lv_jsonx
        IMPORTING
          output_length = lv_output_length
        TABLES
          binary_tab    = lt_binary_tab.
      CALL FUNCTION &apos;SCMS_BINARY_TO_STRING&apos;
        EXPORTING
          input_length  = lv_output_length
        IMPORTING
          text_buffer   = rv_json
          output_length = lv_output_length
        TABLES
          binary_tab    = lt_binary_tab.

      &quot; strip {&quot;TEXT&quot;:
      rv_json = rv_json+8.

      &quot; strip trailing }
      lv_output_length = numofchar( rv_json ) - 1.
      rv_json = rv_json(lv_output_length).
    ENDIF.

  ENDMETHOD.                    &quot;abap_to_json_simple_transform

  METHOD serialize_types.
    TYPES:
      BEGIN OF ty_s_data,
        flag    TYPE xfeld,
        char    TYPE c LENGTH 12,
        numc    TYPE n LENGTH 8,
        string  TYPE string,
        xstring TYPE xstring,
        integer TYPE i,
        float   TYPE f,
        packed  TYPE p LENGTH 10 DECIMALS 6,
        hex     TYPE x LENGTH 10,
        guid    TYPE guid_16,
        tsl     TYPE timestampl,
        ts      TYPE timestamp,
        date    TYPE d,
        time    TYPE t,
      END OF ty_s_data.

    CONSTANTS: pi TYPE p LENGTH 8 DECIMALS 14 VALUE &apos;3.14159265358979&apos;,
               tz LIKE sy-zonlo VALUE &apos;UTC&apos;.

    DATA: ls_data  TYPE ty_s_data,
          ls_data2 TYPE ty_s_data,
          lv_json_st TYPE string,
          lv_xml_st  TYPE string,
          lv_act     TYPE string,
          lv_exp   LIKE lv_act.

    ls_data-flag    = abap_true.
    ls_data-char    = &apos;&quot;TEST\&quot;/&apos;.
    ls_data-numc    = 12345678.
    ls_data-string  = &apos;ABCDEFG&apos;.
    ls_data-xstring = ls_data-string.
    ls_data-integer = 42.
    ls_data-float   = pi.
    ls_data-packed  = pi.
    ls_data-hex     = 987654321.
    ls_data-tsl     = &apos;20151002134450.5545900&apos;.
    ls_data-ts      = &apos;20160708123456&apos;.

    CALL FUNCTION &apos;GUID_CREATE&apos;
      IMPORTING
        ev_guid_16 = ls_data-guid.

    CONVERT TIME STAMP ls_data-ts TIME ZONE tz INTO DATE ls_data-date TIME ls_data-time.

    &quot; for reference, let us check how simple transformation works
    lv_json_st = abap_to_json_simple_transform( ls_data ).

    &quot; and XML
    CALL TRANSFORMATION id SOURCE text = ls_data RESULT XML lv_xml_st.

    CLEAR ls_data-guid.

    CONCATENATE `{&quot;FLAG&quot;:true,&quot;CHAR&quot;:&quot;\&quot;TEST\\\&quot;/&quot;,&quot;NUMC&quot;:12345678,&quot;STRING&quot;:&quot;ABCDEFG&quot;,&quot;XSTRING&quot;:&quot;q83v&quot;,&quot;INTEGER&quot;:42,&quot;FLOAT&quot;:3.1415926535897900E+00,`
                `&quot;PACKED&quot;:3.141593,&quot;HEX&quot;:&quot;AAAAAAAAOt5osQ==&quot;,&quot;GUID&quot;:&quot;&quot;,&quot;TSL&quot;:20151002134450.5545900,&quot;TS&quot;:20160708123456,&quot;DATE&quot;:&quot;2016-07-08&quot;,&quot;TIME&quot;:&quot;12:34:56&quot;}` INTO lv_exp.
    lv_act    = /ui2/cl_json=&gt;serialize( data = ls_data ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of data types fails&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_data2 ).
    cl_aunit_assert=&gt;assert_equals( act = ls_data2 exp = ls_data msg = &apos;Deserialization of data types fails&apos; ).

    CONCATENATE `{&quot;FLAG&quot;:true,&quot;CHAR&quot;:&quot;\&quot;TEST\\\&quot;/&quot;,&quot;NUMC&quot;:12345678,&quot;STRING&quot;:&quot;ABCDEFG&quot;,&quot;XSTRING&quot;:&quot;q83v&quot;,&quot;INTEGER&quot;:42,&quot;FLOAT&quot;:3.1415926535897900E+00,`
                `&quot;PACKED&quot;:3.141593,&quot;HEX&quot;:&quot;AAAAAAAAOt5osQ==&quot;,&quot;GUID&quot;:&quot;&quot;,&quot;TSL&quot;:&quot;2015-10-02T13:44:50.5545900Z&quot;,&quot;TS&quot;:&quot;2016-07-08T12:34:56.0000000Z&quot;,&quot;DATE&quot;:&quot;2016-07-08&quot;,&quot;TIME&quot;:&quot;12:34:56&quot;}` INTO lv_exp.
    lv_act    = /ui2/cl_json=&gt;serialize( ts_as_iso8601 = abap_true data = ls_data ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of timestamp into ISO8601 fails&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_data2 ).
    cl_aunit_assert=&gt;assert_equals( act = ls_data2 exp = ls_data msg = &apos;Deserialization of timestamp in ISO8601 fails&apos; ).

    CONCATENATE `{&quot;FLAG&quot;:true,&quot;CHAR&quot;:&quot;\&quot;TEST\\\&quot;\/&quot;,&quot;NUMC&quot;:12345678,&quot;STRING&quot;:&quot;ABCDEFG&quot;,&quot;XSTRING&quot;:&quot;q83v&quot;,&quot;INTEGER&quot;:42,&quot;FLOAT&quot;:3.1415926535897900E+00,`
            `&quot;PACKED&quot;:3.141593,&quot;HEX&quot;:&quot;AAAAAAAAOt5osQ==&quot;,&quot;GUID&quot;:&quot;&quot;,&quot;TSL&quot;:&quot;2015-10-02T13:44:50.5545900Z&quot;,&quot;TS&quot;:&quot;2016-07-08T12:34:56.0000000Z&quot;,&quot;DATE&quot;:&quot;2016-07-08&quot;,&quot;TIME&quot;:&quot;12:34:56&quot;}` INTO lv_act.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_data2 ).
    cl_aunit_assert=&gt;assert_equals( act = ls_data2 exp = ls_data msg = &apos;Deserialization of redunant escapment fails&apos; ).

    &quot; https://blogs.sap.com/2017/01/05/date-and-time-in-sap-gateway-foundation/
    CONCATENATE `{&quot;FLAG&quot;:true,&quot;CHAR&quot;:&quot;\&quot;TEST\\\&quot;/&quot;,&quot;NUMC&quot;:12345678,&quot;STRING&quot;:&quot;ABCDEFG&quot;,&quot;XSTRING&quot;:&quot;q83v&quot;,&quot;INTEGER&quot;:42,&quot;FLOAT&quot;:3.1415926535897900E+00,`
            `&quot;PACKED&quot;:3.141593,&quot;HEX&quot;:&quot;AAAAAAAAOt5osQ==&quot;,&quot;GUID&quot;:&quot;&quot;,&quot;TSL&quot;:&quot;2015-10-02T13:44:50.5545900Z&quot;,&quot;TS&quot;:&quot;\/Date(1467981296000)\/&quot;,&quot;DATE&quot;:&quot;2016-07-08&quot;,&quot;TIME&quot;:&quot;12:34:56&quot;}` INTO lv_act.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_data2 ).
    cl_aunit_assert=&gt;assert_equals( act = ls_data2 exp = ls_data msg = &apos;Deserialization of timestamp in Edm.DateTime fails&apos; ).

    &quot; https://blogs.sap.com/2017/01/05/date-and-time-in-sap-gateway-foundation/
    CONCATENATE `{&quot;FLAG&quot;:true,&quot;CHAR&quot;:&quot;\&quot;TEST\\\&quot;/&quot;,&quot;NUMC&quot;:12345678,&quot;STRING&quot;:&quot;ABCDEFG&quot;,&quot;XSTRING&quot;:&quot;q83v&quot;,&quot;INTEGER&quot;:42,&quot;FLOAT&quot;:3.1415926535897900E+00,`
            `&quot;PACKED&quot;:3.141593,&quot;HEX&quot;:&quot;AAAAAAAAOt5osQ==&quot;,&quot;GUID&quot;:&quot;&quot;,&quot;TSL&quot;:&quot;2015-10-02T13:44:50.5545900Z&quot;,&quot;TS&quot;:&quot;\/Date(1467981296000)\/&quot;,&quot;DATE&quot;:&quot;2016-07-08&quot;,&quot;TIME&quot;:&quot;PT12H34M56S&quot;}` INTO lv_act.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act CHANGING data = ls_data2 ).
    cl_aunit_assert=&gt;assert_equals( act = ls_data2 exp = ls_data msg = &apos;Deserialization of timestamp in Edm.Time fails&apos; ).

  ENDMETHOD.                    &quot;serialize_types

  METHOD serialize_associative_array.
    TYPES:
      BEGIN OF ty_s_data,
        key1   TYPE string,
        key2   TYPE i,
        value1 TYPE string,
      END OF ty_s_data.

    DATA: lt_table1  TYPE STANDARD TABLE OF ty_s_data,
          lt_table2  TYPE SORTED TABLE OF ty_s_data WITH NON-UNIQUE KEY key1,
          lt_table3  TYPE SORTED TABLE OF ty_s_data WITH UNIQUE KEY key1,
          lt_table4  TYPE HASHED TABLE OF ty_s_data WITH UNIQUE KEY key1,
          lt_table5  TYPE HASHED TABLE OF ty_s_data WITH UNIQUE KEY key1 key2,
          lt_table6  TYPE HASHED TABLE OF ty_s_data WITH UNIQUE KEY table_line,
          ls_table   TYPE ty_s_data,
          lv_counter TYPE n LENGTH 2.

    DATA: lv_act TYPE string,
          lv_exp LIKE lv_act.

    DO 3 TIMES.
      CONCATENATE `k1` lv_counter INTO ls_table-key1.
      MOVE lv_counter TO ls_table-key2.
      CONCATENATE `v1` lv_counter INTO ls_table-value1.
      APPEND ls_table TO lt_table1.
      ADD 1 TO lv_counter.
    ENDDO.

    lt_table6 = lt_table5 = lt_table4 = lt_table3 = lt_table2 = lt_table1.

    lv_exp = &apos;[{&quot;key1&quot;:&quot;k100&quot;,&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},{&quot;key1&quot;:&quot;k101&quot;,&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},{&quot;key1&quot;:&quot;k102&quot;,&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}]&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table1 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of standard fails&apos; ).

    lv_exp = &apos;[{&quot;key1&quot;:&quot;k100&quot;,&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},{&quot;key1&quot;:&quot;k101&quot;,&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},{&quot;key1&quot;:&quot;k102&quot;,&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}]&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table2 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of sorted table with non-unique fails&apos; ).

    lv_exp = &apos;{&quot;k100&quot;:{&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},&quot;k101&quot;:{&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},&quot;k102&quot;:{&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table3 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of sorted table with unique fails&apos; ).

    lv_exp = &apos;{&quot;k100&quot;:{&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},&quot;k101&quot;:{&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},&quot;k102&quot;:{&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table4 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of hashed table with single unique key fails&apos; ).

    lv_exp = &apos;{&quot;k100-0&quot;:{&quot;key1&quot;:&quot;k100&quot;,&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},&quot;k101-1&quot;:{&quot;key1&quot;:&quot;k101&quot;,&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},&quot;k102-2&quot;:{&quot;key1&quot;:&quot;k102&quot;,&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table5 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of hashed table with multi unique keys fails&apos; ).

    lv_exp = &apos;{&quot;k100-0-v100&quot;:{&quot;key1&quot;:&quot;k100&quot;,&quot;key2&quot;:0,&quot;value1&quot;:&quot;v100&quot;},&quot;k101-1-v101&quot;:{&quot;key1&quot;:&quot;k101&quot;,&quot;key2&quot;:1,&quot;value1&quot;:&quot;v101&quot;},&quot;k102-2-v102&quot;:{&quot;key1&quot;:&quot;k102&quot;,&quot;key2&quot;:2,&quot;value1&quot;:&quot;v102&quot;}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_table6 pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of hashed table with unique key as table line fails&apos; ).

  ENDMETHOD.                    &quot;serialize_associative_array

  METHOD serialize_form_factor.
    TYPES:
      BEGIN OF t_form_factor,
        desktop TYPE abap_bool,
        tablet  TYPE boolean,
        phone   TYPE abap_bool,
      END OF t_form_factor,
      BEGIN OF t_form_factors,
        app_default TYPE boole_d,
        manual      TYPE t_form_factor,
      END OF t_form_factors,
      BEGIN OF t_root,
        form_factors TYPE t_form_factors,
      END OF t_root.

    DATA: ls_data TYPE t_root,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    ls_data-form_factors-app_default    = abap_true.
    ls_data-form_factors-manual-desktop = abap_false.
    ls_data-form_factors-manual-tablet  = abap_true.
    ls_data-form_factors-manual-phone   = abap_true.

    lv_exp = &apos;{&quot;formFactors&quot;:{&quot;appDefault&quot;:true,&quot;manual&quot;:{&quot;desktop&quot;:false,&quot;tablet&quot;:true,&quot;phone&quot;:true}}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of form factor structure fails&apos; ).

    lv_exp = &apos;{&quot;formFactors&quot;:{&quot;appDefault&quot;:true,&quot;manual&quot;:{&quot;tablet&quot;:true,&quot;phone&quot;:true}}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case compress = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of form factor structure with compression fails&apos; ).

    lv_exp = &apos;{&quot;FORM_FACTORS&quot;:{&quot;APP_DEFAULT&quot;:true,&quot;MANUAL&quot;:{&quot;TABLET&quot;:true,&quot;PHONE&quot;:true}}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = abap_false compress = abap_true ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of form factor structure with NO PRETTY NAME fails&apos; ).

  ENDMETHOD.                    &quot;serialize_form_factor

  METHOD serialize_table.

    TYPES:
      BEGIN OF t_form_factor,
        desktop TYPE abap_bool,
        tablet  TYPE boolean,
        phone   TYPE boole_d,
      END OF t_form_factor,
      BEGIN OF t_line,
        index   TYPE i,
        user    LIKE sy-uname,
        client  LIKE sy-mandt,
        ff      TYPE t_form_factor,
        strings TYPE string_table.
            INCLUDE   TYPE t_form_factor.
    TYPES: END OF t_line .
    TYPES: t_table TYPE HASHED TABLE OF t_line WITH UNIQUE KEY index.

    DATA: lt_data TYPE t_table,
          ls_data LIKE LINE OF lt_data,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    ls_data-index       = 1.
    ls_data-user        = &apos;USER1&apos;.
    ls_data-client      = &apos;000&apos;.
    ls_data-ff-desktop  = abap_false.
    ls_data-ff-tablet   = /ui2/cl_json=&gt;c_tribool-true.
    ls_data-ff-phone    = abap_false.
    ls_data-desktop     = abap_true.
    ls_data-tablet      = /ui2/cl_json=&gt;c_tribool-false.
    ls_data-phone       = abap_true.

    APPEND &apos;ABC&apos; TO ls_data-strings.
    APPEND &apos;BCD&apos; TO ls_data-strings.

    INSERT ls_data INTO TABLE lt_data.

    CLEAR: ls_data.

    ls_data-index       = 2.
    ls_data-user        = &apos;USER2&apos;.
    ls_data-client      = &apos;111&apos;.
    ls_data-ff-desktop  = abap_true.
    ls_data-ff-tablet   = /ui2/cl_json=&gt;c_tribool-true.
    ls_data-ff-phone    = abap_false.
    ls_data-desktop     = abap_false.
    ls_data-tablet      = /ui2/cl_json=&gt;c_tribool-false.
    ls_data-phone       = abap_true.

    APPEND &apos;DEF&apos; TO ls_data-strings.

    INSERT ls_data INTO TABLE lt_data.

    CONCATENATE `[{&quot;index&quot;:1,&quot;user&quot;:&quot;USER1&quot;,&quot;client&quot;:&quot;000&quot;,&quot;ff&quot;:{&quot;desktop&quot;:false,&quot;tablet&quot;:true,&quot;phone&quot;:false},&quot;strings&quot;:[&quot;ABC&quot;,&quot;BCD&quot;],&quot;desktop&quot;:true,&quot;tablet&quot;:false,&quot;phone&quot;:true},`
                `{&quot;index&quot;:2,&quot;user&quot;:&quot;USER2&quot;,&quot;client&quot;:&quot;111&quot;,&quot;ff&quot;:{&quot;desktop&quot;:true,&quot;tablet&quot;:true,&quot;phone&quot;:false},&quot;strings&quot;:[&quot;DEF&quot;],&quot;desktop&quot;:false,&quot;tablet&quot;:false,&quot;phone&quot;:true}]`
                INTO lv_exp.

    lv_act = /ui2/cl_json=&gt;serialize( data = lt_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of the table in JSON fails&apos; ).

  ENDMETHOD.                    &quot;serialize_table

  METHOD serialize_ref.

    DATA: lt_data TYPE abap_parmbind_tab,
          ls_data LIKE LINE OF lt_data,
          lv_int  TYPE int4,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    ls_data-name = &apos;INTERGER&apos;.
    ls_data-kind = &apos;E&apos;.
    lv_int = 3.
    GET REFERENCE OF lv_int INTO ls_data-value.
    INSERT ls_data INTO TABLE lt_data.

    lv_exp = `[{&quot;NAME&quot;:&quot;INTERGER&quot;,&quot;KIND&quot;:&quot;E&quot;,&quot;VALUE&quot;:3}]`.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_data ).

*    DATA: xml  TYPE string.
*    CALL TRANSFORMATION id OPTIONS data_refs = &apos;embedded&apos;
*                           SOURCE lt_data = lt_data
*                           RESULT XML xml.                  &quot;#EC NOTEXT

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of data reference fails&apos; ).

  ENDMETHOD.                    &quot;serialize_ref

  METHOD serialize_upper_camel_case.
    DATA:
      BEGIN OF ls_data,
        __underscore      TYPE abap_bool VALUE abap_true,
        under__score      TYPE abap_bool VALUE abap_true,
        _upper_camel_case TYPE abap_bool VALUE abap_true,
        camel_case        TYPE abap_bool VALUE abap_true,
        lowcase           TYPE abap_bool VALUE abap_true,
        distance_a_b      TYPE abap_bool VALUE abap_true,
      END OF ls_data.

    DATA: ls_act  LIKE ls_data,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    lv_exp = &apos;{&quot;_underscore&quot;:true,&quot;under_score&quot;:true,&quot;UpperCamelCase&quot;:true,&quot;camelCase&quot;:true,&quot;lowcase&quot;:true,&quot;distanceAB&quot;:true}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization in camel case fails&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_data msg = &apos;Deserialization in camel case fails&apos; ).

  ENDMETHOD.                    &quot;serialize_upper_camel_case

  METHOD deserialize_camel_case.
    TYPES:
      BEGIN OF t_data,
        __underscore      TYPE abap_bool,
        under__score      TYPE abap_bool,
        _upper_camel_case TYPE abap_bool,
        camel_case        TYPE abap_bool,
        lowcase           TYPE abap_bool,
      END OF t_data.

    DATA: ls_act  TYPE t_data,
          ls_exp  TYPE t_data,
          lv_json TYPE string.

    ls_exp-__underscore      = abap_true.
    ls_exp-under__score      = abap_true.
    ls_exp-_upper_camel_case = abap_true.
    ls_exp-camel_case        = abap_true.
    ls_exp-lowcase           = abap_true.

    CLEAR: ls_act.
    lv_json = &apos;{&quot;_underscore&quot;:true,&quot;under_score&quot;:true,&quot;UpperCamelCase&quot;:true,&quot;camelCase&quot;:true,&quot;lowcase&quot;:true}&apos;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Deserialization in camel case fails&apos; ).

    CLEAR: ls_act.
    lv_json = &apos;{&quot;_underscore&quot;:true,&quot;under_score&quot;:true,&quot;UpperCamelCase&quot;:true,&quot;CamelCase&quot;:true,&quot;lowcase&quot;:true}&apos;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Deserialization of not well formed JSON names in camel case fails&apos; ).

  ENDMETHOD.                    &quot;deserialize_camel_case

  METHOD serialize_included_types.
    TYPES:
      BEGIN OF lty_include_pos,
        include TYPE progname,
        pos     TYPE i,
      END OF lty_include_pos .
    TYPES:
      BEGIN OF lty_source_object,
        includes      TYPE SORTED TABLE OF lty_include_pos WITH UNIQUE KEY include,
        path          TYPE string,
        source        TYPE string,
        source_length TYPE i,
      END OF lty_source_object .
    TYPES:
      BEGIN OF lty_issue,
        id       TYPE string,
        msg      TYPE string,
        priority TYPE string,
        line     TYPE i,
      END OF lty_issue .
    TYPES: lty_issues TYPE STANDARD TABLE OF lty_issue  WITH DEFAULT KEY.
    TYPES: BEGIN OF lty_object,
             objtype TYPE string,
             objname TYPE string,
             issues  TYPE lty_issues.
    INCLUDE TYPE lty_source_object AS source_object RENAMING WITH SUFFIX _INC.
    TYPES: END OF lty_object .
    TYPES:
      lty_objects TYPE STANDARD TABLE OF lty_object  WITH DEFAULT KEY .
    TYPES:
      BEGIN OF lty_result,
        objects TYPE lty_objects,
      END OF lty_result .

    DATA: ls_data TYPE lty_result,
          lv_act  TYPE string,
          lv_exp  LIKE lv_act.

    DATA: ls_object TYPE LINE OF lty_objects.

    APPEND ls_object TO ls_data-objects.

    lv_exp = &apos;{&quot;objects&quot;:[{&quot;objtype&quot;:&quot;&quot;,&quot;objname&quot;:&quot;&quot;,&quot;issues&quot;:[],&quot;includesInc&quot;:[],&quot;pathInc&quot;:&quot;&quot;,&quot;sourceInc&quot;:&quot;&quot;,&quot;sourceLengthInc&quot;:0}]}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of included types with alias fails!&apos; ).

  ENDMETHOD.                    &quot;serialize_included_types

  METHOD deserialize_ref.

    DATA: lv_data TYPE string,
          lt_act  TYPE abap_parmbind_tab,
          ls_act  LIKE LINE OF lt_act,
          lv_int  TYPE int4,
          lv_str  TYPE string,
          lv_bool TYPE abap_bool,
          ls_data LIKE LINE OF lt_act,
          lt_exp  LIKE lt_act,
          ls_exp  LIKE LINE OF lt_exp.

    ls_data-name = &apos;INTERGER&apos;.
    ls_data-kind = &apos;E&apos;.
    lv_int = 3.
    GET REFERENCE OF lv_int INTO ls_data-value.
    INSERT ls_data INTO TABLE lt_exp.

    ls_data-name = &apos;STRING&apos;.
    ls_data-kind = &apos;E&apos;.
    lv_str = &apos;Test&apos;.
    GET REFERENCE OF lv_str INTO ls_data-value.
    INSERT ls_data INTO TABLE lt_exp.

    ls_data-name = &apos;BOOL&apos;.
    ls_data-kind = &apos;E&apos;.
    lv_bool = abap_true.
    GET REFERENCE OF lv_bool INTO ls_data-value.
    INSERT ls_data INTO TABLE lt_exp.

    lv_data = `[{&quot;NAME&quot;:&quot;INTERGER&quot;,&quot;KIND&quot;:&quot;E&quot;,&quot;VALUE&quot;:3},{&quot;NAME&quot;:&quot;STRING&quot;,&quot;KIND&quot;:&quot;E&quot;,&quot;VALUE&quot;:&quot;Test&quot;},{&quot;NAME&quot;:&quot;BOOL&quot;,&quot;KIND&quot;:&quot;E&quot;,&quot;VALUE&quot;:true}]`.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data CHANGING data = lt_act ).

    READ TABLE lt_act INTO ls_act WITH TABLE KEY name = &apos;INTERGER&apos;.
    READ TABLE lt_exp INTO ls_exp WITH TABLE KEY name = &apos;INTERGER&apos;.

    cl_aunit_assert=&gt;assert_equals( act = ls_act-name exp = ls_exp-name msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-kind exp = ls_exp-kind msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-value exp = ls_exp-value msg = &apos;Serialization of data reference fails&apos; ).

    READ TABLE lt_act INTO ls_act WITH TABLE KEY name = &apos;STRING&apos;.
    READ TABLE lt_exp INTO ls_exp WITH TABLE KEY name = &apos;STRING&apos;.

    cl_aunit_assert=&gt;assert_equals( act = ls_act-name exp = ls_exp-name msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-kind exp = ls_exp-kind msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-value exp = ls_exp-value msg = &apos;Serialization of data reference fails&apos; ).

    READ TABLE lt_act INTO ls_act WITH TABLE KEY name = &apos;BOOL&apos;.
    READ TABLE lt_exp INTO ls_exp WITH TABLE KEY name = &apos;BOOL&apos;.

    cl_aunit_assert=&gt;assert_equals( act = ls_act-name exp = ls_exp-name msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-kind exp = ls_exp-kind msg = &apos;Serialization of data reference fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = ls_act-value exp = ls_exp-value msg = &apos;Serialization of data reference fails&apos; ).


  ENDMETHOD.                    &quot;deserialize_ref

  METHOD deserialize_form_factor.

    DATA: json TYPE string.

    TYPES:
      BEGIN OF t_form_factor,
        desktop TYPE abap_bool,
        tablet  TYPE abap_bool,
        phone   TYPE abap_bool,
      END OF t_form_factor,
      BEGIN OF t_form_factors,
        app_default TYPE abap_bool,
        manual      TYPE t_form_factor,
      END OF t_form_factors,
      BEGIN OF t_root,
        form_factors TYPE t_form_factors,
      END OF t_root.

    DATA: lv_act TYPE t_root,
          lv_exp LIKE lv_act.

    lv_exp-form_factors-app_default    = abap_true.
    lv_exp-form_factors-manual-desktop = abap_false.
    lv_exp-form_factors-manual-tablet  = abap_true.
    lv_exp-form_factors-manual-phone   = abap_true.

    CONCATENATE &apos;{ &quot;formFactors&quot;: {&apos;            cl_abap_char_utilities=&gt;cr_lf
                &apos;    &quot;appDefault&quot; :  true,&apos;     cl_abap_char_utilities=&gt;cr_lf
                &apos;    &quot;manual&quot;: {&apos;               cl_abap_char_utilities=&gt;cr_lf
                &apos;         &quot;desktop&quot;: false,&apos;    cl_abap_char_utilities=&gt;cr_lf
                &apos;         &quot;tablet&quot;: true,&apos;      cl_abap_char_utilities=&gt;cr_lf
                &apos;         &quot;phone&quot;: true&apos;        cl_abap_char_utilities=&gt;cr_lf
                &apos;         }&apos;                    cl_abap_char_utilities=&gt;cr_lf
                &apos;    }&apos;                         cl_abap_char_utilities=&gt;cr_lf
                &apos;}&apos; INTO json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialization of JSON fails&apos; ).

  ENDMETHOD.       &quot;deserialize_form_factor

  METHOD deserialize_malformed.

    DATA: json TYPE string.

    TYPES:
      BEGIN OF tp_s_rating,
        question_id TYPE string,
        value       TYPE i,
      END OF tp_s_rating,
      tp_t_rating TYPE STANDARD TABLE OF tp_s_rating WITH KEY question_id.

    DATA: lv_act TYPE tp_t_rating.

    TRY .
        json = `{&quot;text&quot;: &quot;x&apos;s feedback&quot;,&quot;ratings&quot;: [{&quot;question_id&quot;:&quot;Q1&quot;,&quot;value&quot;:3},{&quot;question_id&quot;:&quot;Q2&quot;,&quot;value&quot;:4},{&quot;question_id&quot;:&quot;Q3&quot;,&quot;value&quot;:6}`.
        /ui2/cl_json=&gt;deserialize( EXPORTING json = json CHANGING data = lv_act ).
      CATCH cx_sy_move_cast_error.
        CLEAR lv_act.
      CATCH cx_root.                                     &quot;#EC CATCH_ALL
        CLEAR lv_act.
    ENDTRY.

    cl_aunit_assert=&gt;assert_initial( act = lv_act msg = &apos;Deserialization of wrong JSON object fails&apos; ).

    json = &apos;{ &quot;userName&quot;: &quot;sap&quot;, &quot;password&quot;: &quot;123456&quot; }&apos;.
    DATA: BEGIN OF user,
            username TYPE string,
            password TYPE int4,
          END OF user.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json CHANGING data = user ).

    cl_aunit_assert=&gt;assert_equals( act = user-username exp = &apos;sap&apos;  msg = &apos;Deserialization of wrong JSON object fails&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = user-password exp = 123456 msg = &apos;Deserialization of wrong JSON object fails&apos; ).

  ENDMETHOD.                    &quot;deserialize_malformed

  METHOD deserialize_non_fitting_table.

    TYPES:
      BEGIN OF tp_s_person,
        id    TYPE string,
        fname TYPE string,
        lname TYPE string,
        age   TYPE string,
        hobby TYPE string,
      END OF tp_s_person,
      tp_t_person TYPE STANDARD TABLE OF tp_s_person WITH KEY id.

    DATA: json TYPE string,
          itab TYPE tp_t_person.

    FIELD-SYMBOLS: &lt;line&gt; LIKE LINE OF itab.

    &quot;*****************************************************************

    json = `[{&quot;ID&quot;:&quot;2222&quot;,&quot;FIRST_NAME&quot;:&quot;Latha&quot;,&quot;LNAME&quot;:&quot;BH&quot;,&quot;AGE&quot;:&quot;40&quot;,&quot;HOBBY&quot;:&quot;Reading&quot;}]`.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json CHANGING data = itab ).

    cl_aunit_assert=&gt;assert_not_initial( act = itab msg = &apos;Deserialization of table with missing field&apos; ).
    READ TABLE itab INDEX 1 ASSIGNING &lt;line&gt;.
    cl_aunit_assert=&gt;assert_initial( act = &lt;line&gt;-fname msg = &apos;Deserialization of table with missing field&apos; ).

    &quot;******************************************************************

    json = `[{&quot;IDX&quot;:&quot;2222&quot;,&quot;FNAMEX&quot;:&quot;Latha&quot;,&quot;LNAMEX&quot;:&quot;BH&quot;,&quot;AGEX&quot;:&quot;40&quot;,&quot;HOBBYX&quot;:&quot;Reading&quot;}]`.

    CLEAR itab.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = json CHANGING data = itab ).

    cl_aunit_assert=&gt;assert_not_initial( act = itab msg = &apos;Deserialization of table with missing field&apos; ).
    READ TABLE itab INDEX 1 ASSIGNING &lt;line&gt;.
    cl_aunit_assert=&gt;assert_initial( act = &lt;line&gt; msg = &apos;Deserialization of table with missing field&apos; ).

  ENDMETHOD.                    &quot;deserialize_non_fitting_table

  METHOD deserialize_target_mapping.

    DATA: json TYPE string.

    TYPES:
      BEGIN OF t_form_factor,
        desktop TYPE abap_bool,
        tablet  TYPE abap_bool,
        phone   TYPE abap_bool,
      END OF t_form_factor,
      BEGIN OF t_form_factors,
        app_default TYPE abap_bool,
        manual      TYPE t_form_factor,
      END OF t_form_factors,
      BEGIN OF t_tm_config,
        semantic_object              TYPE string,
        semantic_action              TYPE string,
        navigation_provider          TYPE string,
        navigation_provider_role     TYPE string,
        navigation_provider_instance TYPE string,
        target_application_alias     TYPE string,
        mapping_signature            TYPE string,
        display_info_text            TYPE string,
        form_factors                 TYPE t_form_factors,
      END OF t_tm_config,
      BEGIN OF t_config,
        tile_configuration TYPE string,
      END OF t_config.

    DATA: lv_temp TYPE t_config,
          lv_act  TYPE t_tm_config,
          lv_exp  LIKE lv_act.

    lv_act-form_factors-app_default    = abap_false.
    lv_act-form_factors-manual-desktop = abap_true.
    lv_act-form_factors-manual-tablet  = abap_true.
    lv_act-form_factors-manual-phone   = abap_true.
    lv_act-display_info_text           = &apos;default text&apos;.

    lv_exp = lv_act.
    lv_exp-semantic_object              = &apos;SalesOrder&apos;.
    lv_exp-semantic_action              = &apos;showFactsheet&apos;.
    lv_exp-navigation_provider          = &apos;LPD&apos;.
    lv_exp-navigation_provider_role     = &apos;UI3_SRVC&apos;.
    lv_exp-navigation_provider_instance = &apos;UI2_FIORI_CHECKS&apos;.
    lv_exp-target_application_alias     = &apos;FactsheetApp&apos;.
    lv_exp-display_info_text            = &apos;&apos;.

    CONCATENATE &apos;{&quot;tileConfiguration&quot;:&quot;{\&quot;semantic_object\&quot;:\&quot;SalesOrder\&quot;,\&quot;semantic_action\&quot;:\&quot;showFactsheet\&quot;,\&quot;navigation_provider\&quot;:\&quot;LPD\&quot;,\&quot;navigation_provider_role\&quot;:\&quot;UI3_SRVC\&quot;,\&quot;navigation_provider_instance\&quot;:\&quot;UI2_FIORI_CHECKS\&quot;,&apos;
                &apos;\&quot;target_application_alias\&quot;:\&quot;FactsheetApp\&quot;,\&quot;unknown\&quot;:100.00,\&quot;display_info_text\&quot;:\&quot;\&quot;}&quot;}&apos; INTO json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_temp ).
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_temp-tile_configuration pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialization of JSON fails&apos; ).

**********************************************************************

    CLEAR lv_act.

    lv_act-form_factors-app_default    = abap_false.
    lv_act-form_factors-manual-desktop = abap_true.
    lv_act-form_factors-manual-tablet  = abap_true.
    lv_act-form_factors-manual-phone   = abap_true.
    lv_act-display_info_text           = &apos;default text&apos;.

    lv_exp = lv_act.
    lv_exp-semantic_object              = &apos;&apos;.
    lv_exp-semantic_action              = &apos;&apos;.
    lv_exp-navigation_provider          = &apos;LPD&apos;.
    lv_exp-navigation_provider_role     = &apos;&apos;.
    lv_exp-navigation_provider_instance = &apos;&apos;.
    lv_exp-target_application_alias     = &apos;&apos;.
    lv_exp-display_info_text            = &apos;&apos;.
    lv_exp-mapping_signature            = &apos;{par1=vallkl}&amp;[par2=Eyallk]&apos;.
    lv_exp-form_factors-app_default    = abap_true.
    lv_exp-form_factors-manual-desktop = abap_true.
    lv_exp-form_factors-manual-tablet  = abap_true.
    lv_exp-form_factors-manual-phone   = abap_true.

    CONCATENATE  &apos;{&quot;tileConfiguration&quot;:&quot;{\&quot;semantic_object\&quot;:\&quot;\&quot;,\&quot;semantic_action\&quot;:\&quot;\&quot;,\&quot;navigation_provider\&quot;:\&quot;LPD\&quot;,\&quot;display_info_text\&quot;:\&quot;\&quot;,\&quot;form_factors\&quot;:{\&quot;appDefault\&quot;:true,\&quot;manual\&quot;:&apos;
                 &apos;{\&quot;desktop\&quot;:true,\&quot;tablet\&quot;:true,\&quot;phone\&quot;:true}},\&quot;mapping_signature\&quot;:\&quot;{par1=vallkl}&amp;[par2=Eyallk]\&quot;,\&quot;rows\&quot;:[{\&quot;mandatory\&quot;:true,\&quot;defaultValue\&quot;:\&quot;\&quot;,\&quot;isRegularExpression\&quot;:true,&apos;
                 &apos;\&quot;name\&quot;:\&quot;par1\&quot;,\&quot;value\&quot;:\&quot;vallkl\&quot;,\&quot;valEnabled\&quot;:true,\&quot;defValEnabled\&quot;:false},{\&quot;mandatory\&quot;:false,\&quot;isRegularExpression\&quot;:false,\&quot;value\&quot;:\&quot;\&quot;,\&quot;name\&quot;:\&quot;par2\&quot;,\&quot;defaultValue\&quot;:&apos;
                 &apos;\&quot;Eyallk\&quot;,\&quot;valEnabled\&quot;:false,\&quot;defValEnabled\&quot;:true}]}&quot;}&apos; INTO json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_temp ).
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_temp-tile_configuration pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialization of JSON with array fails&apos; ).

**********************************************************************
    CLEAR lv_act.

    lv_act-form_factors-app_default    = abap_false.
    lv_act-form_factors-manual-desktop = abap_true.
    lv_act-form_factors-manual-tablet  = abap_true.
    lv_act-form_factors-manual-phone   = abap_true.
    lv_act-display_info_text           = &apos;default text&apos;.

    lv_exp = lv_act.
    lv_exp-semantic_object              = &apos;Action&apos;.
    lv_exp-semantic_action              = &apos;toUrlOnOtherServer&apos;.
    lv_exp-navigation_provider          = &apos;LPD&apos;.
    lv_exp-navigation_provider_role     = &apos;FLP_SAMPLE&apos;.
    lv_exp-navigation_provider_instance = &apos;UI_INTEGRATION_SAMPLES&apos;.
    lv_exp-target_application_alias     = &apos;toUrlOnOtherServer&apos;.
    lv_exp-display_info_text            = &apos;&quot;Manage Products&quot; app on another server&apos;.
    lv_exp-mapping_signature            = &apos;*=*&apos;.
    lv_exp-form_factors-app_default    = abap_false.
    lv_exp-form_factors-manual-desktop = abap_true.
    lv_exp-form_factors-manual-tablet  = abap_true.
    lv_exp-form_factors-manual-phone   = abap_true.

    CONCATENATE  &apos;{&quot;tileConfiguration&quot;:&quot;{\&quot;semantic_object\&quot;:\&quot;Action\&quot;,\&quot;semantic_action\&quot;:\&quot;toUrlOnOtherServer\&quot;,&apos;
                 &apos;\&quot;display_title_text\&quot;:\&quot;\&quot;,\&quot;url\&quot;:\&quot;\&quot;,\&quot;ui5_component\&quot;:\&quot;\&quot;,\&quot;navigation_provider\&quot;:\&quot;LPD\&quot;,&apos;
                 &apos;\&quot;navigation_provider_role\&quot;:\&quot;FLP_SAMPLE\&quot;,\&quot;navigation_provider_instance\&quot;:\&quot;UI_INTEGRATION_SAMPLES\&quot;,&apos;
                 &apos;\&quot;target_application_id\&quot;:\&quot;\&quot;,\&quot;target_application_alias\&quot;:\&quot;toUrlOnOtherServer\&quot;,&apos;
                 &apos;\&quot;display_info_text\&quot;:\&quot;\\\&quot;Manage Products\\\&quot; app on another server\&quot;,\&quot;mapping_signature\&quot;:\&quot;*=*\&quot;}&quot;}&apos; INTO json.

    TRY.
        /ui2/cl_json=&gt;deserialize( EXPORTING json = json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_temp ).
        /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_temp-tile_configuration pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_act ).
      CATCH cx_sy_move_cast_error. &quot; JSON structure is invalid
        CLEAR lv_act.
    ENDTRY.

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialization of JSON with array fails&apos; ).

  ENDMETHOD.       &quot;deserialize_target_mapping

  METHOD deserialize_array.

    DATA: json TYPE string.

    TYPES:
      BEGIN OF t_form_factor,
        desktop TYPE abap_bool,
        tablet  TYPE abap_bool,
        phone   TYPE abap_bool,
      END OF t_form_factor,
      BEGIN OF t_form_factors,
        app_default TYPE abap_bool,
        manual      TYPE t_form_factor,
      END OF t_form_factors,
      BEGIN OF tp_s_sig_param,
        name                TYPE string,
        value               TYPE string,
        default_value       TYPE string,
        mandatory           TYPE abap_bool,
        isregularexpression TYPE abap_bool,
        val_enabled         TYPE abap_bool,
        def_val_enabled     TYPE abap_bool,
      END OF tp_s_sig_param,
      tp_t_sig_param TYPE SORTED TABLE OF tp_s_sig_param WITH NON-UNIQUE KEY name,
      BEGIN OF t_tm_config,
        semantic_object              TYPE string,
        semantic_action              TYPE string,
        navigation_provider          TYPE string,
        navigation_provider_role     TYPE string,
        navigation_provider_instance TYPE string,
        target_application_alias     TYPE string,
        mapping_signature            TYPE string,
        display_info_text            TYPE string,
        rows                         TYPE tp_t_sig_param,
        form_factors                 TYPE t_form_factors,
      END OF t_tm_config,
      BEGIN OF t_config,
        tile_configuration TYPE string,
      END OF t_config.

    DATA: lv_temp TYPE t_config,
          lv_act  TYPE t_tm_config,
          ls_row  TYPE LINE OF tp_t_sig_param,
          lv_exp  LIKE lv_act.

    lv_act-form_factors-app_default    = abap_false.
    lv_act-form_factors-manual-desktop = abap_true.
    lv_act-form_factors-manual-tablet  = abap_true.
    lv_act-form_factors-manual-phone   = abap_true.
    lv_act-display_info_text           = &apos;default text&apos;.

    lv_exp = lv_act.
    lv_exp-form_factors-app_default     = abap_true.
    lv_exp-semantic_object              = &apos;SalesOrder&apos;.
    lv_exp-semantic_action              = &apos;showFactsheet&apos;.
    lv_exp-navigation_provider          = &apos;LPD&apos;.
    lv_exp-navigation_provider_role     = &apos;UI3_SRVC&apos;.
    lv_exp-navigation_provider_instance = &apos;UI2_FIORI_CHECKS&apos;.
    lv_exp-target_application_alias     = &apos;FactsheetApp&apos;.
    lv_exp-display_info_text            = &apos;&apos;.
    lv_exp-mapping_signature            = &apos;{par1=vallkl}&amp;[par2=Eyallk]&apos;.

    ls_row-name                  = &apos;par1&apos;.
    ls_row-value                 = &apos;vallkl&apos;.
    ls_row-default_value         = &apos;&apos;.
    ls_row-mandatory             = abap_true.
    ls_row-isregularexpression   = abap_true.
    ls_row-val_enabled           = abap_true.
    ls_row-def_val_enabled       = abap_false.
    INSERT ls_row INTO TABLE lv_exp-rows.

    ls_row-name                  = &apos;par2&apos;.
    ls_row-value                 = &apos;&apos;.
    ls_row-default_value         = &apos;Eyallk&apos;.
    ls_row-mandatory             = abap_false.
    ls_row-isregularexpression   = abap_false.
    ls_row-val_enabled           = abap_false.
    ls_row-def_val_enabled       = abap_true.
    INSERT ls_row INTO TABLE lv_exp-rows.

    CONCATENATE  &apos;{&quot;tileConfiguration&quot;:&quot;{\&quot;semantic_object\&quot;:\&quot;SalesOrder\&quot;,\&quot;semantic_action\&quot;:\&quot;showFactsheet\&quot;,\&quot;navigation_provider\&quot;:\&quot;LPD\&quot;,\&quot;display_info_text\&quot;:\&quot;\&quot;,\&quot;form_factors\&quot;:{\&quot;appDefault\&quot;:true,\&quot;manual\&quot;:&apos;
                 &apos;{\&quot;desktop\&quot;:true,\&quot;tablet\&quot;:true,\&quot;phone\&quot;:true}},\&quot;mapping_signature\&quot;:\&quot;{par1=vallkl}&amp;[par2=Eyallk]\&quot;,\&quot;rows\&quot;:[{\&quot;mandatory\&quot;:true,\&quot;defaultValue\&quot;:\&quot;\&quot;,\&quot;isRegularExpression\&quot;:true,&apos;
                 &apos;\&quot;name\&quot;:\&quot;par1\&quot;,\&quot;value\&quot;:\&quot;vallkl\&quot;,\&quot;valEnabled\&quot;:true,\&quot;defValEnabled\&quot;:false},{\&quot;mandatory\&quot;:false,\&quot;isRegularExpression\&quot;:false,\&quot;value\&quot;:\&quot;\&quot;,\&quot;name\&quot;:\&quot;par2\&quot;,\&quot;defaultValue\&quot;:&apos;
                 &apos;\&quot;Eyallk\&quot;,\&quot;valEnabled\&quot;:false,\&quot;defValEnabled\&quot;:true}],&apos;
                 &apos;\&quot;target_application_alias\&quot;:\&quot;FactsheetApp\&quot;,\&quot;navigation_provider_role\&quot;:\&quot;UI3_SRVC\&quot;,\&quot;navigation_provider_instance\&quot;:\&quot;UI2_FIORI_CHECKS\&quot; }&quot;}&apos; INTO json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_temp ).
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_temp-tile_configuration pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialization of JSON with array fails&apos; ).

    DATA: lt_exp TYPE string_table,
          lt_act LIKE lt_exp.

    APPEND &apos;A&apos; TO lt_exp.
    APPEND &apos;B&apos; TO lt_exp.
    APPEND &apos;C&apos; TO lt_exp.

    json = `[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]`.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = json CHANGING data = lt_act ).
    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Deserialization of STRING_TABLE fails&apos; ).

  ENDMETHOD.       &quot;deserialize_target_mapping_array

  METHOD deserialize_types.
    TYPES:
      BEGIN OF t_struct,
        negative_i TYPE i,
        positive_i TYPE i,
        positive_n TYPE n LENGTH 6,
        timestamp  TYPE timestamp,
        boolean    TYPE abap_bool,
        special1   TYPE string,
        special2   TYPE string,
      END OF t_struct.

    DATA: lv_exp  TYPE t_struct,
          lv_act  TYPE t_struct,
          lv_data TYPE string.

    lv_exp-negative_i = -1.
    lv_exp-positive_i = 10000.
    lv_exp-positive_n = 1.
    lv_exp-timestamp  = 1419279663821.
    lv_exp-boolean    = abap_true.
    lv_exp-special1   = `2016/05/11`.
    CONCATENATE `tena` cl_abap_char_utilities=&gt;newline `t` INTO lv_exp-special2.

    lv_data = &apos;{&quot;negative_i&quot;:-1,&quot;positive_i&quot;:10000,&quot;positive_n&quot;:1,&quot;boolean&quot;:true,&quot;timestamp&quot;:1419279663821,&quot;timestamp_not_mapped&quot;:1419279663821,&quot;special1&quot;:&quot;2016/05/11&quot;,&quot;special2&quot;:&quot;tena\nt&quot;}&apos;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data pretty_name = /ui2/cl_json=&gt;pretty_mode-low_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialize of types with low case name pretty printing fails&apos; ).

    lv_data = &apos;{&quot;negative_i&quot;: -1, &quot;positive_i&quot;:10000, &quot;positive_n&quot; : &quot;000001&quot;, &quot;boolean&quot; : true, &quot;timestamp&quot; : 1419279663821, &quot;timestamp_not_mapped&quot; : 1419279663821,&quot;special1&quot;:&quot;2016/05/11&quot;,&quot;special2&quot;:&quot;tena\nt&quot;}&apos;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data pretty_name = /ui2/cl_json=&gt;pretty_mode-low_case CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialize of types with low case name pretty printing fails&apos; ).

  ENDMETHOD.                    &quot;deserialize_types

  METHOD deserialize_news.
    TYPES: BEGIN OF tp_s_tile_news_config,
             defaultimage    TYPE string,
             cycleinterval   TYPE i,
             refreshinterval TYPE string,
             usedefaultimage TYPE abap_bool,
             feed1           TYPE string,
             feed2           TYPE string,
             feed3           TYPE string,
             feed4           TYPE string,
             feed5           TYPE string,
             feed6           TYPE string,
             feed7           TYPE string,
             feed8           TYPE string,
             feed9           TYPE string,
             feed10          TYPE string,
             ifilter1        TYPE string,
             ifilter2        TYPE string,
             ifilter3        TYPE string,
             ifilter4        TYPE string,
             ifilter5        TYPE string,
             efilter1        TYPE string,
             efilter2        TYPE string,
             efilter3        TYPE string,
             efilter4        TYPE string,
             efilter5        TYPE string,
           END OF tp_s_tile_news_config .

    DATA: lv_exp  TYPE tp_s_tile_news_config,
          lv_act  TYPE tp_s_tile_news_config,
          lv_data TYPE string.

    CONCATENATE &apos;{&quot;defaultImage&quot;:&quot;http://\\&quot;,&quot;cycleInterval&quot;:&quot;500&quot;,&quot;refreshInterval&quot;:&quot;15 Minutes&quot;,&quot;useDefaultImage&quot;:&quot;false&quot;,&apos;
                &apos;&quot;feed1&quot;:&quot;&quot;,&quot;feed2&quot;:&quot;&quot;,&quot;feed3&quot;:&quot;&quot;,&quot;feed4&quot;:&quot;&quot;,&quot;feed5&quot;:&quot;&quot;,&quot;feed6&quot;:&quot;&quot;,&quot;feed7&quot;:&quot;&quot;,&quot;feed8&quot;:&quot;&quot;,&quot;feed9&quot;:&quot;&quot;,&quot;feed10&quot;:&quot;&quot;,&apos;
                &apos;&quot;iFilter1&quot;:&quot;&quot;,&quot;iFilter2&quot;:&quot;&quot;,&quot;iFilter3&quot;:&quot;&quot;,&quot;iFilter4&quot;:&quot;&quot;,&quot;iFilter5&quot;:&quot;&quot;,&quot;eFilter1&quot;:&quot;&quot;,&quot;eFilter2&quot;:&quot;&quot;,&quot;eFilter3&quot;:&quot;&quot;,&quot;eFilter4&quot;:&quot;&quot;,&quot;eFilter5&quot;:&quot;&quot;}&apos;
                INTO lv_data.

    lv_exp-defaultimage     = &apos;http://\&apos;.
    lv_exp-cycleinterval    = &apos;500&apos;.
    lv_exp-refreshinterval  = &apos;15 Minutes&apos;.
    lv_exp-usedefaultimage  = abap_false.

    TRY.
        /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data pretty_name = /ui2/cl_json=&gt;pretty_mode-low_case CHANGING data = lv_act ).
      CATCH cx_sy_move_cast_error. &quot; JSON structure is invalid
        CLEAR lv_act.
    ENDTRY.

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialize of types with low case name prety printing fails&apos; ).

**********************************************************************

    CONCATENATE &apos;{&quot;defaultImage&quot;:&quot;http://\\\\&quot;,&quot;cycleInterval&quot;:500,&quot;refreshInterval&quot;:&quot;15 Minutes&quot;,&quot;useDefaultImage&quot;:&quot;true&quot;,&apos;
                &apos;&quot;feed1&quot;:&quot;&quot;,&quot;feed2&quot;:&quot;&quot;,&quot;feed3&quot;:&quot;&quot;,&quot;feed4&quot;:&quot;&quot;,&quot;feed5&quot;:&quot;&quot;,&quot;feed6&quot;:&quot;&quot;,&quot;feed7&quot;:&quot;&quot;,&quot;feed8&quot;:&quot;&quot;,&quot;feed9&quot;:&quot;&quot;,&quot;feed10&quot;:&quot;&quot;,&apos;
                &apos;&quot;iFilter1&quot;:&quot;&quot;,&quot;iFilter2&quot;:&quot;&quot;,&quot;iFilter3&quot;:&quot;&quot;,&quot;iFilter4&quot;:&quot;&quot;,&quot;iFilter5&quot;:&quot;&quot;,&quot;eFilter1&quot;:&quot;&quot;,&quot;eFilter2&quot;:&quot;&quot;,&quot;eFilter3&quot;:&quot;&quot;,&quot;eFilter4&quot;:&quot;&quot;,&quot;eFilter5&quot;:&quot;&quot;}&apos;
                INTO lv_data.

    lv_exp-defaultimage     = &apos;http://\\&apos;.
    lv_exp-cycleinterval    = &apos;500&apos;.
    lv_exp-refreshinterval  = &apos;15 Minutes&apos;.
    lv_exp-usedefaultimage  = abap_true.

    TRY.
        /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data pretty_name = /ui2/cl_json=&gt;pretty_mode-low_case CHANGING data = lv_act ).
      CATCH cx_sy_move_cast_error. &quot; JSON structure is invalid
        CLEAR lv_act.
    ENDTRY.

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialize of types with low case name prety printing fails&apos; ).

**********************************************************************

  ENDMETHOD.                    &quot;deserialize_news

  METHOD deserialize_dynamic_tile.
    TYPES:
      BEGIN OF tp_s_tile_dynamic_config,
        display_icon_url               TYPE string,
        display_info_text              TYPE string,
        display_title_text             TYPE string,
        display_subtitle_text          TYPE string,
        navigation_use_semantic_object TYPE abap_bool,
        navigation_target_url          TYPE string,
        navigation_semantic_object     TYPE string,
        navigation_semantic_action     TYPE string,
        navigation_semantic_parameters TYPE string,
        display_search_keywords        TYPE string,
        display_number_unit            TYPE string,
        service_url                    TYPE string,
        service_refresh_interval       TYPE i,
      END OF tp_s_tile_dynamic_config .

    DATA: lv_exp  TYPE tp_s_tile_dynamic_config,
          lv_act  TYPE tp_s_tile_dynamic_config,
          lv_data TYPE string.

    CONCATENATE &apos;{&quot;display_icon_url&quot;:&quot;&quot;,&quot;display_title_text&quot;:&quot;&quot;,&quot;di&apos;
                &apos;splay_subtitle_text&quot;:&quot;&quot;,&quot;display_info_text&quot;:&quot;&quot;,&quot;di&apos;
                &apos;splay_number_unit&quot;:&quot;&quot;,&quot;service_url&quot;:&quot;&quot;,&quot;service_re&apos;
                &apos;fresh_interval&quot;:&quot;2343q44we5e55&quot;,&quot;navigation_use_se&apos;
                &apos;mantic_object&quot;:true,&quot;navigation_target_url&quot;:&quot;#Qual&apos;
                &apos;ityNotificationActivity-,..,?ghgh&quot;,&quot;navigation_sem&apos;
                &apos;antic_object&quot;:&quot;QualityNotificationActivity&quot;,&quot;navig&apos;
                &apos;ation_semantic_action&quot;:&quot;,..,&quot;,&quot;navigation_semantic&apos;
                &apos;_parameters&quot;:&quot;ghgh&quot;,&quot;display_search_keywords&quot;:&quot;&quot;}&apos;
    INTO lv_data.

    lv_exp-navigation_use_semantic_object = abap_true.
    lv_exp-navigation_target_url = &apos;#QualityNotificationActivity-,..,?ghgh&apos;.
    lv_exp-navigation_semantic_object = &apos;QualityNotificationActivity&apos;.
    lv_exp-navigation_semantic_action = &apos;,..,&apos;.
    lv_exp-navigation_semantic_parameters = &apos;ghgh&apos;.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data CHANGING data = lv_act ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Deserialize of dynamic tile fails!&apos; ).


  ENDMETHOD.                    &quot;deserialize_dynamic_tile

  METHOD deserialize_associative_array.

    TYPES:
      BEGIN OF tp_s_data,
        key    TYPE string,
        value1 TYPE string,
        value2 TYPE string,
      END OF tp_s_data,
      tp_t_data TYPE HASHED TABLE OF tp_s_data WITH UNIQUE KEY key.

    DATA: lt_exp   TYPE tp_t_data,
          ls_exp   LIKE LINE OF lt_exp,
          lt_act   TYPE tp_t_data,
          lv_lines TYPE i,
          lv_data  TYPE string.

    CONCATENATE &apos;{ &quot;key1&quot;: { &quot;value1&quot; : &quot;test1&quot;, &quot;value2&quot; : &quot;test1&quot; },&apos;
                &apos;  &quot;key2&quot;: { &quot;value1&quot; : &quot;test2&quot;, &quot;value2&quot; : &quot;test2&quot; },&apos;
                &apos;  &quot;key3&quot;: { &quot;value1&quot; : &quot;test3&quot;, &quot;value2&quot; : &quot;test3&quot; } }&apos;
    INTO lv_data.

    ls_exp-key    = &apos;key1&apos;.
    ls_exp-value1 = &apos;test1&apos;.
    ls_exp-value2 = &apos;test1&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    ls_exp-key    = &apos;key2&apos;.
    ls_exp-value1 = &apos;test2&apos;.
    ls_exp-value2 = &apos;test2&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    ls_exp-key    = &apos;key3&apos;.
    ls_exp-value1 = &apos;test3&apos;.
    ls_exp-value2 = &apos;test3&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data assoc_arrays = abap_true CHANGING data = lt_act ).
    lv_lines = lines( lt_act ).
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 3 msg = &apos;Deserialize of associated array fails!&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Deserialize of associated array fails!&apos; ).

  ENDMETHOD.                    &quot;deserialize_associative_array

  METHOD deserialize_array_table_line.

    TYPES:
     tp_t_data TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line.

    DATA: lt_exp   TYPE tp_t_data,
          ls_exp   LIKE LINE OF lt_exp,
          lt_act   TYPE tp_t_data,
          lv_lines TYPE i,
          lv_data  TYPE string.

    CONCATENATE &apos;{ &quot;key1&quot;: {},&apos;
                &apos;  &quot;key2&quot;: {},&apos;
                &apos;  &quot;key3&quot;: {} }&apos;
    INTO lv_data.

    ls_exp = &apos;key1&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    ls_exp = &apos;key2&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    ls_exp = &apos;key3&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data assoc_arrays = abap_true CHANGING data = lt_act ).
    lv_lines = lines( lt_act ).
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 3 msg = &apos;Deserialize of associated array with key as table_line fails!&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Deserialize of associated array with key as table_line fails!&apos; ).

  ENDMETHOD.                    &quot;deserialize_array_table_line

  METHOD deserialize_empty_structure.

    TYPES: BEGIN OF t_cuan_loy_s_beacon,
             id       TYPE string,
             major_id TYPE i,
             minor_id TYPE i,
           END OF t_cuan_loy_s_beacon.
    TYPES: t_cuan_loy_t_beacon TYPE STANDARD TABLE OF t_cuan_loy_s_beacon WITH DEFAULT KEY.
    TYPES: BEGIN OF t_cuan_loy_s_offer,
             offer_id             TYPE string,
             offer_code           TYPE string,
             offer_type           TYPE string,
             target_group         TYPE string,
             valid_to             TYPE timestamp,
             enable_geo_marketing TYPE abap_bool,
             email_templ_id       TYPE string,
             beacon               TYPE t_cuan_loy_t_beacon,
           END OF t_cuan_loy_s_offer.
    TYPES: t_cuan_loy_t_offer TYPE STANDARD TABLE OF t_cuan_loy_s_offer WITH DEFAULT KEY.

    DATA: lt_exp    TYPE t_cuan_loy_t_offer,
          ls_exp    LIKE LINE OF lt_exp,
          ls_beacon TYPE LINE OF t_cuan_loy_t_beacon,
          lt_act    LIKE lt_exp,
          lv_data   TYPE string.

    CONCATENATE
      &apos;[ {&apos;
      &apos;  &quot;beacon&quot; : [ { } ],&apos;
      &apos;  &quot;enableGeoMarketing&quot; : false,&apos;
      &apos;  &quot;offerCode&quot; : &quot;lsFHQZHz&quot;,&apos;
      &apos;  &quot;offerId&quot; : &quot;b70f045ff2214edaab8904d6b427b52d&quot;,&apos;
      &apos;  &quot;offerStatus&quot; : &quot;INACTIVE&quot;,&apos;
      &apos;  &quot;offerType&quot; : &quot;COUPON&quot;,&apos;
      &apos;  &quot;targetGroup&quot; : [ &quot;31cd621d165b4c9f87d652760f414a53&quot; ],&apos;
      &apos;  &quot;validFrom&quot; : &quot;2016-01-14T19:02:14.320+0000&quot;,&apos;
      &apos;  &quot;validTo&quot; : &quot;2016-01-27T19:02:14.324+0000&quot;&apos;
      &apos;}, {&apos;
      &apos;  &quot;beacon&quot; : [ {&apos;
      &apos;    &quot;id&quot; : &quot;B9407F30-F5F8-466E-AFF9-25556B57FE6D&quot;,&apos;
      &apos;    &quot;majorId&quot; : 103&apos;
      &apos;  } ],&apos;
      &apos;  &quot;enableGeoMarketing&quot; : true,&apos;
      &apos;  &quot;offerCode&quot; : &quot;575tpNAk&quot;,&apos;
      &apos;  &quot;offerId&quot; : &quot;a46e801e067e46098e93fcd1d9e34f01&quot;,&apos;
      &apos;  &quot;offerStatus&quot; : &quot;INACTIVE&quot;,&apos;
      &apos;  &quot;offerType&quot; : &quot;COUPON&quot;,&apos;
      &apos;  &quot;targetGroup&quot; : [ &quot;31cd621d165b4c9f87d652760f414a53&quot;, &quot;eb83bd07b89f462e8538cdcbf5c62164&quot;, &quot;dcd160b0af6d495f9b8e0c6c5edae47c&quot; ],&apos;
      &apos;  &quot;validTo&quot; : &quot;2016-01-31T09:51:23.702+0000&quot;&apos;
      &apos;}]&apos;
    INTO lv_data.

    CLEAR: ls_exp.

    ls_exp-offer_id               = &apos;b70f045ff2214edaab8904d6b427b52d&apos;.
    ls_exp-offer_code             = &apos;lsFHQZHz&apos;.
    ls_exp-offer_type             = &apos;COUPON&apos;.
    ls_exp-valid_to               = &apos;20160127190214&apos;.
    ls_exp-enable_geo_marketing   = abap_false.
    APPEND ls_beacon TO ls_exp-beacon.
    APPEND ls_exp TO lt_exp.

    CLEAR: ls_exp.

    ls_exp-offer_id               = &apos;a46e801e067e46098e93fcd1d9e34f01&apos;.
    ls_exp-offer_code             = &apos;575tpNAk&apos;.
    ls_exp-offer_type             = &apos;COUPON&apos;.
    ls_exp-valid_to               = &apos;20160131095124&apos;.
    ls_exp-enable_geo_marketing   = abap_true.

    ls_beacon-id                  = &apos;B9407F30-F5F8-466E-AFF9-25556B57FE6D&apos;.
    ls_beacon-major_id            = 103.
    ls_beacon-minor_id            = 0.
    APPEND ls_beacon TO ls_exp-beacon.
    APPEND ls_exp TO lt_exp.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lt_act ).

    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Deserialize of table with empty objects fails!&apos; ).

  ENDMETHOD.                    &quot;deserialize_empty_structure

  METHOD serialize_recursive.

    TYPES: BEGIN OF ts_node,
             id       TYPE i,
             children TYPE STANDARD TABLE OF REF TO data WITH DEFAULT KEY,
           END OF ts_node.

    DATA: lv_exp  TYPE string,
          lv_act  TYPE string,
          ls_data TYPE ts_node,
          lr_data LIKE REF TO ls_data.

    ls_data-id = 1.

    CREATE DATA lr_data.
    lr_data-&gt;id = 2.
    APPEND lr_data TO ls_data-children.

    lv_exp = &apos;{&quot;ID&quot;:1,&quot;CHILDREN&quot;:[{&quot;ID&quot;:2,&quot;CHILDREN&quot;:[]}]}&apos;.

    lv_act = /ui2/cl_json=&gt;serialize( data = ls_data ).
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of recursive data structure fails&apos; ).

  ENDMETHOD.                    &quot;serialize_recursive

  METHOD serialize_object.

    DATA: lv_exp   TYPE string,
          lv_act   TYPE string,
          lo_data  TYPE REF TO lcl_test,
          lo_child LIKE lo_data.

    CREATE OBJECT lo_data.
    lo_data-&gt;id = 1.

    CREATE OBJECT lo_child.
    lo_child-&gt;id = 2.
    APPEND lo_child TO lo_data-&gt;children.

    lv_exp = &apos;{&quot;CHILDREN&quot;:[{&quot;CHILDREN&quot;:[],&quot;ID&quot;:2}],&quot;ID&quot;:1}&apos;.

    lv_act = /ui2/cl_json=&gt;serialize( data = lo_data ).
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of simple recursive object fails&apos; ).

  ENDMETHOD.                    &quot;serialize_object

  METHOD deserialize_object.

    DATA: lo_data  TYPE REF TO lcl_test,
          lv_act   TYPE i,
          lv_lines LIKE sy-tabix,
          lv_data  TYPE string.

    lv_data = &apos;{&quot;id&quot;:1,&quot;children&quot;:[{&quot;id&quot;:2,&quot;children&quot;:[]}]}&apos;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_data CHANGING data =  lo_data ).

    cl_aunit_assert=&gt;assert_not_initial( act = lo_data msg = &apos;Deserialization of simple recursive object fails&apos; ).

    lv_act = lo_data-&gt;id.
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = 1 msg = &apos;Deserialization of simple recursive object fails&apos; ).

    lv_lines = lines( lo_data-&gt;children ).
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 1 msg = &apos;Deserialization of simple recursive object fails&apos; ).

    READ TABLE lo_data-&gt;children INDEX 1 INTO lo_data.
    lv_act = lo_data-&gt;id.
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = 2 msg = &apos;Deserialization of simple recursive object fails&apos; ).

  ENDMETHOD.                    &quot;deserialize_object

  METHOD deserialize_partial.

    TYPES: BEGIN OF ts_record,
             id        TYPE string,
             m_columns TYPE /ui2/cl_json=&gt;json,
           END OF ts_record.

    DATA: lv_json TYPE string,
          lt_act  TYPE SORTED TABLE OF ts_record WITH UNIQUE KEY id,
          lt_exp  LIKE lt_act,
          ls_exp  LIKE LINE OF lt_exp.

    CONCATENATE &apos;{&quot;O000001ZZ_SO_GRES_CONTACTS&quot;:{&quot;mColumns&quot;:{&quot;AGE&quot;:{&quot;bVisible&quot;:true,&quot;iPosition&quot;:2},&quot;BRSCH&quot;:{&quot;bVisible&quot;:true}}},&apos;
                &apos;&quot;O000001ZZ_TRANSIENT_TEST_A&quot;:{&quot;mColumns&quot;:{&quot;ABTNR&quot;:{&quot;bVisible&quot;:false},&quot;CITY1&quot;:{&quot;bVisible&quot;:false},&quot;IC_COMPANY_KEY&quot;:{&quot;bVisible&quot;:true}}}}&apos;
                INTO lv_json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json assoc_arrays = abap_true pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = lt_act ).

    ls_exp-id = &apos;O000001ZZ_SO_GRES_CONTACTS&apos;.
    ls_exp-m_columns = &apos;{&quot;AGE&quot;:{&quot;bVisible&quot;:true,&quot;iPosition&quot;:2},&quot;BRSCH&quot;:{&quot;bVisible&quot;:true}}&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    ls_exp-id = &apos;O000001ZZ_TRANSIENT_TEST_A&apos;.
    ls_exp-m_columns = &apos;{&quot;ABTNR&quot;:{&quot;bVisible&quot;:false},&quot;CITY1&quot;:{&quot;bVisible&quot;:false},&quot;IC_COMPANY_KEY&quot;:{&quot;bVisible&quot;:true}}&apos;.
    INSERT ls_exp INTO TABLE lt_exp.

    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Partial deserialization fails&apos; ).

  ENDMETHOD.                    &quot;deserialize_partial

  METHOD serialize_partial.

    TYPES: BEGIN OF ts_record,
             id        TYPE string,
             m_columns TYPE /ui2/cl_json=&gt;json,
           END OF ts_record.

    DATA: lv_exp TYPE /ui2/cl_json=&gt;json,
          lv_act TYPE /ui2/cl_json=&gt;json,
          lt_act TYPE SORTED TABLE OF ts_record WITH UNIQUE KEY id,
          ls_act LIKE LINE OF lt_act.

    CONCATENATE &apos;{&quot;O000001ZZ_SO_GRES_CONTACTS&quot;:{&quot;mColumns&quot;:{&quot;AGE&quot;:{&quot;bVisible&quot;:true,&quot;iPosition&quot;:2},&quot;BRSCH&quot;:{&quot;bVisible&quot;:true}}},&apos;
                &apos;&quot;O000001ZZ_TRANSIENT_TEST_A&quot;:{&quot;mColumns&quot;:{&quot;ABTNR&quot;:{&quot;bVisible&quot;:false},&quot;CITY1&quot;:{&quot;bVisible&quot;:false},&quot;IC_COMPANY_KEY&quot;:{&quot;bVisible&quot;:true}}}}&apos;
                INTO lv_exp.

    ls_act-id = &apos;O000001ZZ_SO_GRES_CONTACTS&apos;.
    ls_act-m_columns = &apos;{&quot;AGE&quot;:{&quot;bVisible&quot;:true,&quot;iPosition&quot;:2},&quot;BRSCH&quot;:{&quot;bVisible&quot;:true}}&apos;.
    INSERT ls_act INTO TABLE lt_act.

    ls_act-id = &apos;O000001ZZ_TRANSIENT_TEST_A&apos;.
    ls_act-m_columns = &apos;{&quot;ABTNR&quot;:{&quot;bVisible&quot;:false},&quot;CITY1&quot;:{&quot;bVisible&quot;:false},&quot;IC_COMPANY_KEY&quot;:{&quot;bVisible&quot;:true}}&apos;.
    INSERT ls_act INTO TABLE lt_act.

    lv_act = /ui2/cl_json=&gt;serialize( data = lt_act assoc_arrays = abap_true pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Partial serialization fails&apos; ).

  ENDMETHOD.                    &quot;serialize_partial

  METHOD custom_compressible.

    TYPES:
      BEGIN OF tp_s_data,
        tribool TYPE lc_json_custom=&gt;tribool,
        bool    TYPE lc_json_custom=&gt;bool,
        str     TYPE string,
        initial TYPE i,
      END OF tp_s_data.

    DATA: ls_data            TYPE tp_s_data,
          lo_json            TYPE REF TO /ui2/cl_json,
          lo_json_custom     TYPE REF TO lc_json_custom,
          lv_json            TYPE lc_json_custom=&gt;json,
          lv_json_custom_exp LIKE lv_json,
          lv_json_custom     LIKE lv_json.

    ls_data-tribool = lc_json_custom=&gt;c_tribool-false.
    ls_data-bool    = lc_json_custom=&gt;c_bool-false.
    ls_data-str     = &apos;&apos;.
    ls_data-initial  = 0.

    CREATE OBJECT lo_json
      EXPORTING
        compress = abap_true.

    CREATE OBJECT lo_json_custom
      EXPORTING
        compress = abap_true.

    lv_json = lo_json-&gt;serialize_int( data = ls_data ).
    lv_json_custom = lo_json_custom-&gt;serialize_int( data = ls_data ).

    lv_json_custom_exp = `{&quot;TRIBOOL&quot;:false,&quot;STR&quot;:&quot;&quot;,&quot;INITIAL&quot;:0}`.

    cl_aunit_assert=&gt;assert_equals( act = lv_json_custom exp = lv_json_custom_exp msg = &apos;Custom compressable fails!&apos; ).
    cl_aunit_assert=&gt;assert_differs( act = lv_json exp = lv_json_custom msg = &apos;Custom compressable fails!&apos; ).

  ENDMETHOD.                    &quot;custom_compressible

  METHOD custom_pretty_name.
    TYPES:
      BEGIN OF tp_s_data,
        tribool TYPE lc_json_custom=&gt;tribool,
        bool    TYPE lc_json_custom=&gt;bool,
        str1    TYPE string,
        str2    TYPE string,
        initial TYPE i,
      END OF tp_s_data.

    DATA: ls_exp         TYPE tp_s_data,
          ls_act         LIKE ls_exp,
          lo_json_custom TYPE REF TO lc_json_custom,
          lv_json_custom TYPE lc_json_custom=&gt;json.

    ls_exp-tribool = lc_json_custom=&gt;c_tribool-false.
    ls_exp-bool    = lc_json_custom=&gt;c_bool-false.
    ls_exp-str1     = &apos;&apos;.
    ls_exp-str2     = &apos;ABC&apos;.
    ls_exp-initial  = 0.

    CREATE OBJECT lo_json_custom
      EXPORTING
        compress    = abap_true
        pretty_name = lc_json_custom=&gt;pretty_mode-camel_case.

    lv_json_custom = lo_json_custom-&gt;serialize_int( data = ls_exp ).
    lo_json_custom-&gt;deserialize_int( EXPORTING json = lv_json_custom CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Custom pretty name fails!&apos; ).

  ENDMETHOD.                    &quot;custom_pretty_name

  METHOD custom_pretty_name2.

    TYPES:
      BEGIN OF tp_s_data,
        sschema             TYPE string,
        odatacontext        TYPE string,
        shortened_abap_name TYPE string,
        standard            TYPE string,
      END OF tp_s_data.

    DATA: ls_exp      TYPE tp_s_data,
          ls_act      LIKE ls_exp,
          lr_data    TYPE REF TO data,
          lv_string  TYPE string,
          lt_mapping TYPE /ui2/cl_json=&gt;name_mappings,
          ls_mapping LIKE LINE OF lt_mapping,
          lo_data    TYPE REF TO /ui2/cl_data_access,
          lo_json     TYPE REF TO /ui2/cl_json,
          lv_json     TYPE lc_json_custom=&gt;json.

    ls_exp-sschema              = `abc1`.
    ls_exp-odatacontext         = `abc2`.
    ls_exp-shortened_abap_name  = `abc3`.
    ls_exp-standard             = `abc4`.

    &quot; pre-fill name mapping table
    ls_mapping-abap = `SSCHEMA`.
    ls_mapping-json = `$schema`.
    INSERT ls_mapping INTO TABLE lt_mapping.

    ls_mapping-abap = `ODATACONTEXT`.
    ls_mapping-json = `@odata.context`.
    INSERT ls_mapping INTO TABLE lt_mapping.

    ls_mapping-abap = `SHORTENED_ABAP_NAME`.
    ls_mapping-json = `VeeeeryyyyyLooooongJSONAttrbuuuuuuuuuteeeeeeeeeee`.
    INSERT ls_mapping INTO TABLE lt_mapping.

*    lt_mapping = VALUE #(
*      ( in = `SSCHEMA` out = `$schema` )
*      ( in = `ODATACONTEXT` out = `@odata.context` )
*      ( in = `SHORTENED_ABAP_NAME` out = `VeeeeryyyyyLooooongJSONAttrbuuuuuuuuuteeeeeeeeeee` )
*    ).

    CREATE OBJECT lo_json
      EXPORTING
        pretty_name   = /ui2/cl_json=&gt;pretty_mode-low_case
        name_mappings    = lt_mapping
        assoc_arrays     = abap_true
        assoc_arrays_opt = abap_true.

    lv_json = lo_json-&gt;serialize_int( data = ls_exp ).
    lo_json-&gt;deserialize_int( EXPORTING json = lv_json CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Custom pretty name fails!&apos; ).

    &quot; test generation with custom name mappings
    lr_data = lo_json-&gt;generate_int( lv_json ).

    lo_data = /ui2/cl_data_access=&gt;create( ir_data = lr_data iv_component = &apos;shortened_abap_name&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = `abc3` msg = &apos;Generation of OData structure with name mapping fails!&apos; ).

  ENDMETHOD.                    &quot;custom_pretty_name

  METHOD extended_pretty_name.

    TYPES:
      BEGIN OF tp_s_data,
        __d__schema           TYPE string,
        __a__odata___context  TYPE string,
        __e____n____p____m__  TYPE string,
        __s____h____t____l__  TYPE string,
        __c____v____o__       TYPE string,
        _abap_name            TYPE string,
      END OF tp_s_data.

    DATA: ls_exp      TYPE tp_s_data,
          ls_act      LIKE ls_exp,
          lv_exp      TYPE string,
          lo_json     TYPE REF TO /ui2/cl_json,
          lv_json     TYPE lc_json_custom=&gt;json.

    lv_exp = `{&quot;$schema&quot;:&quot;&quot;,&quot;@odata.context&quot;:&quot;&quot;,&quot;!#%&amp;&quot;:&quot;&quot;,&quot;*-~/&quot;:&quot;&quot;,&quot;:|.&quot;:&quot;&quot;,&quot;AbapName&quot;:&quot;&quot;}`.

    lv_json = /ui2/cl_json=&gt;serialize( data = ls_exp pretty_name = /ui2/cl_json=&gt;pretty_mode-extended ).

    cl_aunit_assert=&gt;assert_equals( act = lv_json exp = lv_exp msg = &apos;Extended pretty name fails!&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-extended CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Extended pretty name fails!&apos; ).

  ENDMETHOD.                    &quot;custom_compressible

  METHOD deserialize_alias_type.

    TYPES:
      BEGIN OF lty_data,
        obj_type TYPE string,
        obj_name TYPE string,
      END OF lty_data,
      BEGIN OF lty_source_object,
        path          TYPE string,
        source        TYPE string,
        source_length TYPE i,
      END OF lty_source_object,
      BEGIN OF lty_object,
        id TYPE string.
            INCLUDE TYPE lty_data.
    INCLUDE TYPE lty_source_object AS source_object.
    TYPES: test TYPE abap_bool.
    TYPES: END OF lty_object .

    DATA: ls_act  TYPE lty_object,
          ls_exp  LIKE ls_act,
          lv_json TYPE /ui2/cl_json=&gt;json.

    ls_exp-id             = &apos;21321546&apos;.
    ls_exp-obj_type       = &apos;ABC&apos;.
    ls_exp-obj_name       = &apos;XXX&apos;.
    ls_exp-path           = &apos;/path/to/&apos;.
    ls_exp-source         = &apos;hell.js&apos;.
    ls_exp-source_length  = 256.
    ls_exp-test           = abap_true.

    lv_json = &apos;{&quot;id&quot;:&quot;21321546&quot;,&quot;objType&quot;:&quot;ABC&quot;,&quot;objName&quot;:&quot;XXX&quot;,&quot;sourceObject&quot;:{&quot;path&quot;:&quot;/path/to/&quot;,&quot;source&quot;:&quot;hell.js&quot;,&quot;sourceLength&quot;:256},&quot;test&quot;:true}&apos;.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case
                               CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Deserialisation with alias fails!&apos; ).

  ENDMETHOD.                    &quot;deserialize_alias_type

  METHOD name_value_map.

    TYPES: BEGIN OF ts_record,
             key   TYPE string,
             value TYPE string,
           END OF ts_record,
           BEGIN OF ts_record2,
             key   TYPE string,
             value TYPE ts_record,
           END OF ts_record2.

    DATA: lv_exp  TYPE /ui2/cl_json=&gt;json,
          lv_act  TYPE /ui2/cl_json=&gt;json,
          lt_act  TYPE SORTED TABLE OF ts_record WITH UNIQUE KEY key,
          lt_act2 TYPE SORTED TABLE OF ts_record2 WITH UNIQUE KEY key,
          lt_exp  LIKE lt_act,
          lt_exp2 LIKE  lt_act2,
          ls_exp  LIKE LINE OF lt_act2.

    ls_exp-key         = &apos;KEY1&apos;.
    ls_exp-value-key   = ls_exp-key.
    ls_exp-value-value = &apos;VALUE1&apos;.
    INSERT ls_exp-value INTO TABLE lt_exp.
    INSERT ls_exp INTO TABLE lt_exp2.

    ls_exp-key         = &apos;KEY2&apos;.
    ls_exp-value-key   = ls_exp-key.
    ls_exp-value-value = &apos;VALUE2&apos;.
    INSERT ls_exp-value INTO TABLE lt_exp.
    INSERT ls_exp INTO TABLE lt_exp2.

    lv_exp = &apos;{&quot;KEY1&quot;:&quot;VALUE1&quot;,&quot;KEY2&quot;:&quot;VALUE2&quot;}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_exp assoc_arrays = abap_true assoc_arrays_opt = abap_true ).
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Name/Value map serialization fails!&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act assoc_arrays = abap_true assoc_arrays_opt = abap_true
                               CHANGING  data = lt_act ).
    cl_aunit_assert=&gt;assert_equals( act = lt_act exp = lt_exp msg = &apos;Name/Value map deserialization fails!&apos; ).

    lv_exp = &apos;{&quot;KEY1&quot;:{&quot;KEY&quot;:&quot;KEY1&quot;,&quot;VALUE&quot;:&quot;VALUE1&quot;},&quot;KEY2&quot;:{&quot;KEY&quot;:&quot;KEY2&quot;,&quot;VALUE&quot;:&quot;VALUE2&quot;}}&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lt_exp2 assoc_arrays = abap_true assoc_arrays_opt = abap_true ).
    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Name/Value map serialization fails!&apos; ).

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_act assoc_arrays = abap_true assoc_arrays_opt = abap_true
                               CHANGING  data = lt_exp2 ).
    cl_aunit_assert=&gt;assert_equals( act = lt_exp2 exp = lt_exp2 msg = &apos;Name/Value map deserialization fails!&apos; ).

  ENDMETHOD.                    &quot;name_value_map

  METHOD dynamic_types.

    TYPES:
      BEGIN OF ts_json_meta,
        abap_type LIKE cl_abap_typedescr=&gt;absolute_name,
        data      TYPE /ui2/cl_json=&gt;json,
      END OF ts_json_meta.

    DATA: lt_flight    TYPE STANDARD TABLE OF sflight WITH DEFAULT KEY,
          lv_json      TYPE /ui2/cl_json=&gt;json,
          lo_typedescr TYPE REF TO cl_abap_typedescr,
          lo_data      TYPE REF TO data,
          ls_exp       TYPE ts_json_meta,
          ls_act       LIKE ls_exp.

    FIELD-SYMBOLS: &lt;data&gt; TYPE any.

    SELECT * FROM sflight INTO TABLE lt_flight.         &quot;#EC CI_NOWHERE

    &quot; serialize table lt_flight into JSON, skipping initial fields and converting ABAP field names into camelCase
    ls_exp-data      = /ui2/cl_json=&gt;serialize( data = lt_flight compress = abap_true pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).
    lo_typedescr     = cl_abap_typedescr=&gt;describe_by_data( lt_flight ).
    ls_exp-abap_type = lo_typedescr-&gt;absolute_name.
    lv_json          = /ui2/cl_json=&gt;serialize( data = ls_exp compress = abap_true pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    &quot; deserialize JSON string json into internal table lt_flight doing camelCase to ABAP like field name mapping
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_act ).

    cl_aunit_assert=&gt;assert_equals( act = ls_act exp = ls_exp msg = &apos;Dynamic serialization/deserialization fails!&apos; ).

    CREATE DATA lo_data TYPE (ls_act-abap_type).
    ASSIGN lo_data-&gt;* TO &lt;data&gt;.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = ls_act-data pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = &lt;data&gt; ).

    cl_aunit_assert=&gt;assert_equals( act = &lt;data&gt; exp = lt_flight msg = &apos;Dynamic serialization/deserialization fails!&apos; ).

  ENDMETHOD.                    &quot;dynamic_types

  METHOD deserialize_malformed_type.

    TYPES:
      BEGIN OF ts_record,
        attribute             TYPE c LENGTH 45,
        description           TYPE c LENGTH 60,
        datasource            TYPE string,
        datasourcedescription TYPE c LENGTH 60,
        groupname             TYPE string,
        groupdescription      TYPE c LENGTH 60,
      END OF ts_record.

    DATA: lv_json       TYPE /ui2/cl_json=&gt;json,
          lt_attributes TYPE STANDARD TABLE OF ts_record,
          lv_lines      TYPE i.

    CONCATENATE `[&quot;BO-CUAN_INTERACTION_CONTACT&quot;,&quot;BO-CUAN_INTERACTION_CONTACT/IC_TEAM_MEMBER/SEARCH/AEXE&quot;,`
                `&quot;BO-CUAN_INTERACTION_CONTACT/IC_TEAM_MEMBER/SEARCH/MNGR&quot;,&quot;BO-CUAN_INTERACTION_CONTACT/IC_TEAM_MEMBER/SEARCH/PSAL&quot;,`
                `&quot;BO-CUAN_INTERACTION_CONTACT/IC_TEAM_MEMBER/SEARCH/QUAL&quot;,&quot;BO-CUAN_INTERACTION_CONTACT/IC_TEAM_MEMBER/SEARCH/SUPP&quot;]`
    INTO lv_json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json         = lv_json
                                         pretty_name  = /ui2/cl_json=&gt;pretty_mode-camel_case
                               CHANGING  data         = lt_attributes  ).

    lv_lines = lines( lt_attributes ).

    &quot; because type of record in JSON does not fit to type of record in ABAP we expect to get table with 6 empty rows
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 6 msg = &apos;Deserialization of malformed type table fails!&apos; ).

    &quot; repeat the same in strict mode
    DATA: lo_json TYPE REF TO /ui2/cl_json.

    CREATE OBJECT lo_json
      EXPORTING
        strict_mode = abap_true
        pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case
        compress    = abap_true.

    CLEAR: lt_attributes.
    TRY .
        lo_json-&gt;deserialize_int( EXPORTING json = lv_json CHANGING data = lt_attributes ).
        cl_aunit_assert=&gt;fail( msg = &apos;Test of strict mode with mailformed data fails!&apos; ).
      CATCH cx_sy_move_cast_error.
        lv_lines = lines( lt_attributes ).
        cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 0 msg = &apos;Deserialization of malformed type table fails!&apos; ).
    ENDTRY.

    DATA: BEGIN OF d1,
            abc TYPE i,
            def TYPE string,
            ghi TYPE string_table,
          END OF d1.

    lv_json = `{&quot;abc&quot;: 25, &quot;def&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;ghi&quot; : &quot;&quot; }`.
    TRY .
        lo_json-&gt;deserialize_int( EXPORTING json = lv_json CHANGING data = d1 ).
        cl_aunit_assert=&gt;fail( msg = &apos;Test of strict mode with mailformed data fails!&apos; ).
      CATCH cx_sy_move_cast_error.
        cl_aunit_assert=&gt;assert_initial( act = d1 msg = &apos;Deserialization of malformed type table fails!&apos; ).
    ENDTRY.

  ENDMETHOD.                    &quot;deserialize_malformed_type

  METHOD serialize_dynamic_type.

    DATA:
      ls_comp_descr   TYPE abap_componentdescr,
      lt_comp_descr   TYPE abap_component_tab,
      lo_table_descr  TYPE REF TO cl_abap_tabledescr,
      lo_struct_descr TYPE REF TO cl_abap_structdescr,
      lr_table        TYPE REF TO data,
      lr_line         TYPE REF TO data,
      test_data       TYPE REF TO data,
      lv_act          TYPE /ui2/cl_json=&gt;json,
      lv_exp          TYPE /ui2/cl_json=&gt;json.

    FIELD-SYMBOLS: &lt;table&gt; TYPE ANY TABLE,
                   &lt;line&gt;  TYPE any,
                   &lt;field&gt; TYPE any.

    ls_comp_descr-name = `FIELD1`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_string( ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    ls_comp_descr-name = `FIELD2`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_c( p_length = 30 ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    ls_comp_descr-name = `FIELD3`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_i( ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    ls_comp_descr-name = `FIELD4`.
    CREATE DATA test_data TYPE c LENGTH 30.
    ls_comp_descr-type ?= cl_abap_datadescr=&gt;describe_by_data_ref( p_data_ref = test_data ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    lo_struct_descr = cl_abap_structdescr=&gt;create( p_components = lt_comp_descr ).
    lo_table_descr  = cl_abap_tabledescr=&gt;create( p_line_type = lo_struct_descr ).

    CREATE DATA lr_table TYPE HANDLE lo_table_descr.
    ASSIGN lr_table-&gt;* TO &lt;table&gt;.

    CREATE DATA lr_line LIKE LINE OF &lt;table&gt;.
    ASSIGN lr_line-&gt;* TO &lt;line&gt;.

    ASSIGN COMPONENT `FIELD1` OF STRUCTURE &lt;line&gt; TO &lt;field&gt;.
    &lt;field&gt; = &apos;Hello World!&apos;.

    ASSIGN COMPONENT `FIELD2` OF STRUCTURE &lt;line&gt; TO &lt;field&gt;.
    &lt;field&gt; = &apos;Eat me!&apos;.

    ASSIGN COMPONENT `FIELD3` OF STRUCTURE &lt;line&gt; TO &lt;field&gt;.
    &lt;field&gt; = 20.

    ASSIGN COMPONENT `FIELD4` OF STRUCTURE &lt;line&gt; TO &lt;field&gt;.
    &lt;field&gt; = &apos;I am BIG!&apos;.

    INSERT &lt;line&gt; INTO TABLE &lt;table&gt;.
    INSERT &lt;line&gt; INTO TABLE &lt;table&gt;.

    lv_exp = &apos;[{&quot;field1&quot;:&quot;Hello World!&quot;,&quot;field2&quot;:&quot;Eat me!&quot;,&quot;field3&quot;:20,&quot;field4&quot;:&quot;I am BIG!&quot;},{&quot;field1&quot;:&quot;Hello World!&quot;,&quot;field2&quot;:&quot;Eat me!&quot;,&quot;field3&quot;:20,&quot;field4&quot;:&quot;I am BIG!&quot;}]&apos;.
    lv_act = /ui2/cl_json=&gt;serialize( data = lr_table pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).

    cl_aunit_assert=&gt;assert_equals( act = lv_act exp = lv_exp msg = &apos;Serialization of dynamic type fails!&apos; ).

  ENDMETHOD.                    &quot;serialize_dynamic_type

  METHOD deserialze_to_read_only.

    DATA: lt_flight TYPE STANDARD TABLE OF sflight WITH DEFAULT KEY,
          lv_json   TYPE /ui2/cl_json=&gt;json,
          lo_exp    TYPE REF TO cl_abap_typedescr.

    lo_exp = cl_abap_typedescr=&gt;describe_by_data( lt_flight ).
    lv_json = /ui2/cl_json=&gt;serialize( lo_exp ).
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json CHANGING data = lo_exp ).

  ENDMETHOD.                    &quot;deserialze_to_read_only

  METHOD generate.

    DATA: lv_json   TYPE /ui2/cl_json=&gt;json,
          lv_bool   TYPE abap_bool,
          lv_string TYPE string,
          lo_data   TYPE REF TO /UI2/CL_DATA_ACCESS,
          lr_val    TYPE REF TO data,
          lr_act    TYPE REF TO data.

    CONCATENATE
      `{&quot;code&quot;: &quot;2000&quot;,&quot;message&quot;: &quot;Resource CRUD success&quot;,&quot;output&quot;: {&quot;$schema&quot;:`
      ` &quot;http://json-schema.org/draft-04/schema#&quot;,&quot;title&quot;: &quot;Rule Service&quot;,&quot;id&quot;:`
      ` &quot;#root&quot;,&quot;description&quot;: &quot;Rule service schema&quot;,&quot;required&quot;: [&quot;vocabulary&quot;,`
      ` &quot;executionContext&quot;],&quot;additionalProperties&quot;: true,&quot;properties&quot;: {&quot;descr`
      `iption&quot;: {&quot;description&quot;: &quot;Rule service description&quot;,&quot;type&quot;: &quot;string&quot;,&quot;ma`
      `xLength&quot;: 256},&quot;resultView&quot;: {&quot;description&quot;: &quot;Indicates if result view s`
      `hould be created&quot;,&quot;type&quot;: &quot;string&quot;,&quot;enum&quot;: [&quot;withResultView&quot;, &quot;resultVie`
      `wOnly&quot;]},&quot;executionContext&quot;: {&quot;description&quot;: &quot;Service execution details&quot;`
      `,&quot;id&quot;: &quot;#executionContext&quot;,&quot;type&quot;: &quot;object&quot;,&quot;additionalProperties&quot;: fals`
      `e,&quot;properties&quot;: {&quot;parameters&quot;: {&quot;description&quot;: &quot;Input parameters;&quot;,&quot;type`
      `&quot;: &quot;object&quot;,&quot;required&quot;: [&quot;definition&quot;],&quot;additionalProperties&quot;: false,&quot;pr`
      `operties&quot;: {&quot;definition&quot;: {&quot;description&quot;: &quot;parameters definition&quot;,&quot;type&quot;`
      `: &quot;array&quot;,&quot;items&quot;: {&quot;type&quot;: &quot;object&quot;,&quot;oneOf&quot;: [{&quot;$ref&quot;: &quot;#basicParameter`
      `FirstLevel&quot;}, {&quot;$ref&quot;: &quot;#structureParameterFirstLevel&quot;}, {&quot;$ref&quot;: &quot;#data`
      `ObjectParameter&quot;}]},&quot;uniqueItems&quot;: true},}}},&quot;executionContextDefinition`
      `s&quot;: {&quot;businessDataType&quot;: {&quot;id&quot;: &quot;#businessDataType&quot;,&quot;description&quot;: &quot;Mode`
      `l data type&quot;,&quot;type&quot;: &quot;string&quot;,&quot;enum&quot;: [&quot;String&quot;, &quot;Number&quot;, &quot;Timestamp&quot;, `
      `&quot;Boolean&quot;, &quot;TimeSpan&quot;, &quot;Date&quot;, &quot;Time&quot;]},}},&quot;conversion_Flags_Map&quot;: {&quot;type&quot;`
      `: &quot;object&quot;,&quot;additionalProperties&quot;: false,&quot;properties&quot;: {&quot;is-Value.ListConv`
      `erted&quot;: {&quot;type&quot;: &quot;boolean&quot;,&quot;enum&quot;: [true]}}}},},&quot;details&quot;: []}`
    INTO lv_json.

    lr_act = /ui2/cl_json=&gt;generate( json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).
    cl_aunit_assert=&gt;assert_not_initial( act = lr_act msg = &apos;Generation of ABAP object fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( ir_data = lr_act iv_component = &apos;output-additional_properties&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_bool ).

    cl_aunit_assert=&gt;assert_equals( act = lv_bool exp = abap_true msg = &apos;Generation of boolean for ABAP object fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( ir_data = lr_act iv_component = &apos;output-properties-conversion_flags_map-properties-is_value_list_converted&apos;).
    lr_val = lo_data-&gt;ref( ).

    cl_aunit_assert=&gt;assert_bound( act = lr_val msg = &apos;Generation of deep structure with different pretty name modes fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( ir_data = lr_act iv_component = &apos;output-required[1]&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = &apos;vocabulary&apos; msg = &apos;Generation of table fails!&apos; ).

    DATA:
      ls_comp_descr TYPE abap_componentdescr,
      lt_comp_descr TYPE abap_component_tab.

    ls_comp_descr-name = `FIELD1`.
    ls_comp_descr-suffix = `ABC`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_string( ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    ls_comp_descr-name = `FIELD2`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_c( p_length = 30 ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( iv_data = lt_comp_descr iv_component = &apos;[2]-name&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = &apos;FIELD2&apos; msg = &apos;Dynamic access fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( iv_data = lt_comp_descr iv_component = &apos;[name=FIELD1]-suffix&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = &apos;ABC&apos; msg = &apos;Dynamic access fails!&apos; ).

    lv_json = `{&quot;CODE&quot;: &quot;2000&quot;, &quot;code&quot;: &quot;3000&quot;}`.

    lr_act = /ui2/cl_json=&gt;generate( json = lv_json ).
    cl_aunit_assert=&gt;assert_not_initial( act = lr_act msg = &apos;Generation of ABAP object from JSON with duplicate attributes fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( iv_data = lr_act iv_component = &apos;CODE&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = &apos;2000&apos; msg = &apos;Generation of ABAP object from JSON with duplicate attributes fails!&apos; ).

    lv_json = `{&quot;OrderLinePriceOverrideHistory&quot;: &quot;2000&quot;}`.

    lr_act = /ui2/cl_json=&gt;generate( json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).
    cl_aunit_assert=&gt;assert_not_initial( act = lr_act msg = &apos;Generation of ABAP object from JSON with long attributes fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( iv_data = lr_act iv_component = &apos;ORDER_LINE_PRICE_OVERRIDE_HIST&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_string ).

    cl_aunit_assert=&gt;assert_equals( act = lv_string exp = &apos;2000&apos; msg = &apos;Generation of ABAP object from JSON with long attributes fails!&apos; ).

  ENDMETHOD.                    &quot;generate

  METHOD generate_for_odata.

    DATA: lv_json   TYPE /ui2/cl_json=&gt;json,
          lv_etag   TYPE string,
          lv_date   TYPE p,
          lo_data   TYPE REF TO /ui2/cl_data_access,
          lr_val    TYPE REF TO data,
          lr_act    TYPE REF TO data.

    CONCATENATE
      `{&quot;d&quot;:{&quot;__metadata&quot;:{&quot;uri&quot;:&quot;http://localhost/sap/opu/odata/SAP/API_RECIPE/A_Recipe(guid&apos;42f2e9af-c4ef-1ed8-93db-a01697362280&apos;)&quot;,`
      `&quot;type&quot;:&quot;API_RECIPE.A_RecipeType&quot;,&quot;etag&quot;:&quot;W/\&quot;datetimeoffset&apos;2018-05-03T14%3A19%3A49Z&apos;\&quot;&quot;},&quot;RecipeUUID&quot;:&quot;42f2e9af-c4ef-1ed8-93db-a01697362280&quot;,`
      `&quot;RecipeValidityStartDate&quot;: null,&quot;RecipeLastChangeDateTime&quot;: &quot;\/Date(1525357189000+0000)\/&quot;,&quot;RecipeIsDeleted&quot;: false,&quot;beginDate&quot;:1520781590000,`
      `&quot;to_Characteristics&quot;:{&quot;__deferred&quot;:{&quot;uri&quot;:&quot;http://localhost/sap/opu/odata/SAP/API_RECIPE/A_Recipe(guid&apos;42f2e9af-c4ef-1ed8-93db-a01697362280&apos;)/to_Characteristics&quot;}}}}`
    INTO lv_json.

    lr_act = /ui2/cl_json=&gt;generate( json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case ).
    cl_aunit_assert=&gt;assert_not_initial( act = lr_act msg = &apos;Generation of OData ABAP object fails!&apos; ).

    lo_data = /ui2/cl_data_access=&gt;create( ir_data = lr_act iv_component = &apos;d-__metadata-etag&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_etag ).

    cl_aunit_assert=&gt;assert_equals( act = lv_etag exp = `W/&quot;datetimeoffset&apos;2018-05-03T14%3A19%3A49Z&apos;&quot;` msg = &apos;Generation of OData structure fails!&apos; ).

    lo_data = /ui2/cl_data_access=&gt;create( ir_data = lr_act iv_component = &apos;d-begin_date&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_date ).

    cl_aunit_assert=&gt;assert_equals( act = lv_date exp = `1520781590000` msg = &apos;Generation of OData structure with long int fails!&apos; ).

  ENDMETHOD.                    &quot;generate

  METHOD deserialize_odata.

    DATA: lv_json TYPE /ui2/cl_json=&gt;json.

    DATA:
      BEGIN OF ls_odata_response,
        BEGIN OF d,
          BEGIN OF ____metadata,
            id   TYPE string,
            uri  TYPE string,
            type TYPE string,
          END OF ____metadata,
          id                     TYPE string,
          category               TYPE c LENGTH 1,
          validity               TYPE i,
          client_expiration_time TYPE timestamp,
          component              TYPE string,
          app_name               TYPE string,
          BEGIN OF pers_container_items,
            results TYPE STANDARD TABLE OF string,
          END OF pers_container_items,
        END OF d,
      END OF ls_odata_response.

    CONCATENATE
    `{&quot;d&quot;:{&quot;__metadata&quot;:{&quot;id&quot;:&quot;https://abc.com:1304/sap/opu/odata/UI2/INTEROP/PersContainers(id=&apos;sap.ushell.UserDefaultParameter&apos;,category=&apos;P&apos;)&quot;,`
    `&quot;uri&quot;:&quot;https://abc.com:1304/sap/opu/odata/UI2/INTEROP/PersContainers(id=&apos;sap.ushell.UserDefaultParameter&apos;,category=&apos;P&apos;)&quot;,&quot;type&quot;:&quot;INTEROP.PersContainer&quot;},`
    `&quot;id&quot;:&quot;sap.ushell.UserDefaultParameter&quot;,&quot;category&quot;:&quot;P&quot;,&quot;validity&quot;:0,&quot;clientExpirationTime&quot;:null,&quot;component&quot;:&quot;&quot;,&quot;appName&quot;:&quot;&quot;,&quot;PersContainerItems&quot;:{&quot;results&quot;:[]}}}`
    INTO lv_json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_odata_response ).
    cl_aunit_assert=&gt;assert_not_initial( act = ls_odata_response msg = &apos;Parsing of OData response fails!&apos; ).

    TYPES:
      BEGIN OF ts_result,
        BEGIN OF ____metadata,
          id   TYPE string,
          uri  TYPE string,
          type TYPE string,
          etag TYPE string,
        END OF ____metadata,
        case_guid           TYPE string,
        external_key        TYPE string,
        contact_person_name TYPE string,
      END OF ts_result.

    DATA:
      BEGIN OF ls_odata_response2,
        BEGIN OF d,
          results TYPE STANDARD TABLE OF ts_result WITH DEFAULT KEY,
        END OF d,
      END OF ls_odata_response2.

    CONCATENATE
    `{&quot;d&quot;:{&quot;results&quot;:[{&quot;__metadata&quot;:{&quot;id&quot;:&quot;https://abc.com:44300/sap/opu/odata/sap/UDMO_MANAGE_DISPUTES_SRV/DisputeSet(&apos;.1~3863BB44F0201EE69AD5A3331AE45366&apos;)&quot;,`
    `&quot;uri&quot;:&quot;https://abc.com:44300/sap/opu/odata/sap/UDMO_MANAGE_DISPUTES_SRV/DisputeSet(&apos;.1~3863BB44F0201EE69AD5A3331AE45366&apos;)&quot;,&quot;type&quot;:&quot;UDMO_MANAGE_DISPUTES_SRV.Dispute&quot;,`
    `&quot;etag&quot;:&quot;W/\&quot;datetime&apos;1999-12-14T10%3A18%3A46&apos;\&quot;&quot;},&quot;CaseGuid&quot;:&quot;3863BB44F0201EE69AD5A3331AE45366&quot;,&quot;ExternalKey&quot;:&quot;1452&quot;,&quot;ContactPersonName&quot;:&quot;&quot;}]}}`
    INTO lv_json.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_odata_response2 ).
    cl_aunit_assert=&gt;assert_not_initial( act = ls_odata_response2 msg = &apos;Parsing of OData response fails!&apos; ).

  ENDMETHOD.

  METHOD initialize_on_deserialize.

    DATA:
      BEGIN OF ls_data,
        int       TYPE i VALUE 1,
        num       TYPE n LENGTH 6 VALUE &apos;000001&apos;,
        timestamp TYPE timestamp,
        boolean   TYPE abap_bool VALUE abap_true,
        str       TYPE string VALUE &apos;VALUE&apos;,
        items     TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      END OF ls_data.

    GET TIME STAMP FIELD ls_data-timestamp.
    APPEND &apos;ITEM&apos; TO ls_data-items.

    DATA: lv_json TYPE string.

    lv_json = `{&quot;int&quot;:0,&quot;num&quot;:0,&quot;timestamp&quot;:null,&quot;boolean&quot;:false,&quot;str&quot;:&quot;&quot;,&quot;items&quot;:[]}`.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_data ).
    cl_aunit_assert=&gt;assert_initial( act = ls_data msg = &apos;Initialize of elements on deserialize fails!&apos; ).

  ENDMETHOD.

  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
  &quot; TODO:
  &quot;  - deserilaize into field with REF TO data type, if field is bound, using refrenced data type
  &quot;  - automatic generation of the data, if field has REF TO data type and bound data is initial
  METHOD deserialize_ref_to_data.

    DATA:
      BEGIN OF ls_data,
        str       TYPE string,
        table     TYPE REF TO data,
        struct    TYPE REF TO data,
      END OF ls_data.

    DATA:
      ls_comp_descr   TYPE abap_componentdescr,
      lt_comp_descr   TYPE abap_component_tab,
      lo_table_descr  TYPE REF TO cl_abap_tabledescr,
      lo_struct_descr TYPE REF TO cl_abap_structdescr,
      lo_data         TYPE REF TO /UI2/CL_DATA_ACCESS,
      lv_json         TYPE /ui2/cl_json=&gt;json,
      lv_value        TYPE string,
      lv_lines        TYPE i.

    FIELD-SYMBOLS: &lt;table&gt;  TYPE ANY TABLE,
                   &lt;struct&gt; TYPE any,
                   &lt;field&gt;  TYPE any.

    &quot; Test deserialize on REF TO DATA of known type

    ls_comp_descr-name = `FIELD1`.
    ls_comp_descr-type = cl_abap_elemdescr=&gt;get_string( ).
    INSERT ls_comp_descr INTO TABLE lt_comp_descr.

    lo_struct_descr = cl_abap_structdescr=&gt;create( p_components = lt_comp_descr ).
    lo_table_descr  = cl_abap_tabledescr=&gt;create( p_line_type = lo_struct_descr ).

    CREATE DATA ls_data-table TYPE HANDLE lo_table_descr.

    lv_json = `{&quot;str&quot;:&quot;&quot;,&quot;table&quot;:[{&quot;field1&quot;:&quot;value1&quot;},{&quot;field1&quot;:&quot;value2&quot;}]}`.
    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_data ).

    cl_aunit_assert=&gt;assert_bound( act = ls_data-table msg = &apos;Deserialize to known REF TO data for table fails!&apos; ).

    ASSIGN ls_data-table-&gt;* TO &lt;table&gt;.
    cl_aunit_assert=&gt;assert_subrc( act = sy-subrc msg = &apos;Deserialize to known REF TO data fails!&apos; ).

    lv_lines = lines( &lt;table&gt; ).
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 2 msg = &apos;Deserialize to known REF TO data for table fails!&apos; ).

    &quot; Test implicit generate on tables
    CLEAR ls_data.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_data ).

    cl_aunit_assert=&gt;assert_bound( act = ls_data-table msg = &apos;Deserialize to unknown REF TO data for table fails!&apos; ).

    ASSIGN ls_data-table-&gt;* TO &lt;table&gt;.
    cl_aunit_assert=&gt;assert_subrc( act = sy-subrc msg = &apos;Deserialize to unknown REF TO data for table fails!&apos; ).

    lv_lines = lines( &lt;table&gt; ).
    cl_aunit_assert=&gt;assert_equals( act = lv_lines exp = 2 msg = &apos;Deserialize to unknown REF TO data for table fails!&apos; ).

    &quot; Test deserialize of REF TO DATA of known type for structure
    lv_json = `{&quot;str&quot;:&quot;&quot;,&quot;struct&quot;:{&quot;field1&quot;:&quot;value1&quot;}}`.

    CREATE DATA ls_data-struct TYPE HANDLE lo_struct_descr.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case CHANGING data = ls_data ).
    cl_aunit_assert=&gt;assert_bound( act = ls_data-struct msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).

    ASSIGN ls_data-struct-&gt;* TO &lt;struct&gt;.
    cl_aunit_assert=&gt;assert_subrc( act = sy-subrc msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).

    ASSIGN COMPONENT `FIELD1` OF STRUCTURE &lt;struct&gt; TO &lt;field&gt;.
    cl_aunit_assert=&gt;assert_subrc( act = sy-subrc msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).
    cl_aunit_assert=&gt;assert_equals( act = &lt;field&gt; exp = &apos;value1&apos; msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).

    &quot; Test implicit generate on structures
    CLEAR ls_data.

    /ui2/cl_json=&gt;deserialize( EXPORTING json = lv_json pretty_name = /ui2/cl_json=&gt;pretty_mode-camel_case assoc_arrays = abap_true assoc_arrays_opt = abap_true CHANGING data = ls_data ).
    cl_aunit_assert=&gt;assert_bound( act = ls_data-struct msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).

    lo_data = /UI2/CL_DATA_ACCESS=&gt;create( iv_data = ls_data-struct iv_component = &apos;field1&apos;).
    lo_data-&gt;value( IMPORTING ev_data = lv_value ).
    cl_aunit_assert=&gt;assert_equals( act = lv_value exp = &apos;value1&apos; msg = &apos;Deserialize to unknown REF TO data for struct fails!&apos; ).

  ENDMETHOD.

ENDCLASS.       &quot;abap_unit_testclass</localTestClasses>
 <typeUsage CLSNAME="/UI2/CL_JSON" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
 <forwardDeclaration>ABAP</forwardDeclaration>
 <typeClasDef CLSNAME="/UI2/CL_JSON" TYPEGROUP="CL_ABAP_TSTMP" VERSION="1" TPUTYPE="1" EXPLICIT="X"/>
 <typeClasDef CLSNAME="/UI2/CL_JSON" TYPEGROUP="CX_SY_CONVERSION_ERROR" VERSION="1" TPUTYPE="1" EXPLICIT="X"/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="C_BOOL" VERSION="1" LANGU="1" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="37 " SRCCOLUMN1="4 " SRCROW2="40 " SRCCOLUMN2="29 " TYPESRC_LENG="153 " TYPESRC="BEGIN OF c_bool,
                  true       TYPE bool  VALUE `X`,
                  false      TYPE bool  VALUE ``,
                END OF  c_bool
"/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="C_TRIBOOL" VERSION="1" LANGU="1" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="42 " SRCCOLUMN1="4 " SRCROW2="46 " SRCCOLUMN2="32 " TYPESRC_LENG="228 " TYPESRC="BEGIN OF c_tribool,
                  true       TYPE tribool  VALUE c_bool-true,
                  false      TYPE tribool  VALUE `-`,
                  undefined  TYPE tribool  VALUE ``,
                END OF  c_tribool
"/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MC_BOOL_3STATE" VERSION="1" LANGU="1" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="1" ATTRDONLY="X" ATTVALUE="`\TYPE=BOOLEAN`" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MC_BOOL_TYPES" VERSION="1" LANGU="1" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="1" ATTRDONLY="X" ATTVALUE="`\TYPE-POOL=ABAP\TYPE=ABAP_BOOL\TYPE=BOOLEAN\TYPE=BOOLE_D\TYPE=XFELD`" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MC_JSON_TYPE" VERSION="1" LANGU="1" DESCRIPT="Absolute name of JSON string type" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="1" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MC_KEY_SEPARATOR" VERSION="1" LANGU="1" DESCRIPT="Separator inserted between parts of compound keys" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="`-`" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MC_ME_TYPE" VERSION="1" LANGU="1" DESCRIPT="The class name" EXPOSURE="0" STATE="1" EDITORDER="21 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MT_NAME_MAPPINGS" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="NAME_MAPPINGS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MT_NAME_MAPPINGS_EX" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="NAME_MAPPINGS_EX" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_ASSOC_ARRAYS" VERSION="1" LANGU="1" DESCRIPT="Serialize tables with unique keys as associative array" EXPOSURE="1" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_ASSOC_ARRAYS_OPT" VERSION="1" LANGU="1" DESCRIPT="Optimize rendering of name value maps" EXPOSURE="1" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_COMPRESS" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_EXPAND_INCLUDES" VERSION="1" LANGU="1" DESCRIPT="Expand named includes in structures" EXPOSURE="1" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_EXTENDED" VERSION="1" LANGU="1" DESCRIPT="The class is used as based class" EXPOSURE="0" STATE="1" EDITORDER="19 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_NUMC_AS_STRING" VERSION="1" LANGU="1" DESCRIPT="Dump NUMC fields as strings" EXPOSURE="1" STATE="1" EDITORDER="20 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_PRETTY_NAME" VERSION="1" LANGU="1" EXPOSURE="1" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_STRICT_MODE" VERSION="1" LANGU="1" DESCRIPT="Stop further processing on error" EXPOSURE="1" STATE="1" EDITORDER="18 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="MV_TS_AS_ISO8601" VERSION="1" LANGU="1" DESCRIPT="Dump timestamps as string in ISO8601 format" EXPOSURE="1" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_MODE" VERSION="1" LANGU="1" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="28 " SRCCOLUMN1="4 " SRCROW2="35 " SRCCOLUMN2="34 " TYPESRC_LENG="395 " TYPESRC="BEGIN OF pretty_mode,
                  none          TYPE char1  VALUE ``,
                  low_case      TYPE char1  VALUE `L`,
                  camel_case    TYPE char1  VALUE `X`,
                  extended      TYPE char1  VALUE `Y`,
                  user          TYPE char1  VALUE `U`,
                  user_low_case TYPE char1  VALUE `C`,
                END OF  pretty_mode
"/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="SV_WHITE_SPACE" VERSION="1" LANGU="1" DESCRIPT="White space characters" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="1" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="/UI2/CL_JSON" CMPNAME="VERSION" VERSION="1" LANGU="1" DESCRIPT="Version of the parser logic" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="2" ATTVALUE="6" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="BOOL_TO_TRIBOOL" VERSION="1" LANGU="E" DESCRIPT="Convertes 2 state bool to 3 state bool" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="BOOL_TO_TRIBOOL" SCONAME="IV_BOOL" VERSION="1" LANGU="E" DESCRIPT="2 state boolean type (&apos;X&apos; - true, &apos;&apos; - false)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="BOOL_TO_TRIBOOL" SCONAME="RV_TRIBOOL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TRIBOOL"/>
  <source>METHOD bool_to_tribool.
  IF iv_bool EQ c_bool-true.
    rv_tribool = c_tribool-true.
  ELSEIF iv_bool EQ abap_undefined. &quot; fall back for abap _bool
    rv_tribool = c_tribool-undefined.
  ELSE.
    rv_tribool = c_tribool-false.
  ENDIF.
ENDMETHOD.                    &quot;bool_to_tribool</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <source>METHOD class_constructor.

  DATA: lo_bool_type_descr    TYPE REF TO cl_abap_typedescr,
        lo_tribool_type_descr TYPE REF TO cl_abap_typedescr,
        lo_json_type_descr    TYPE REF TO cl_abap_typedescr,
        lv_pos                LIKE sy-fdpos,
        lv_json_string        TYPE json.

  lo_bool_type_descr    = cl_abap_typedescr=&gt;describe_by_data( c_bool-true ).
  lo_tribool_type_descr = cl_abap_typedescr=&gt;describe_by_data( c_tribool-true ).
  lo_json_type_descr    = cl_abap_typedescr=&gt;describe_by_data( lv_json_string ).

  CONCATENATE mc_bool_types lo_bool_type_descr-&gt;absolute_name lo_tribool_type_descr-&gt;absolute_name INTO mc_bool_types.
  CONCATENATE mc_bool_3state lo_tribool_type_descr-&gt;absolute_name INTO mc_bool_3state.
  CONCATENATE mc_json_type lo_json_type_descr-&gt;absolute_name INTO mc_json_type.

  FIND FIRST OCCURRENCE OF `\TYPE=` IN lo_json_type_descr-&gt;absolute_name MATCH OFFSET lv_pos.
  IF sy-subrc IS INITIAL.
    mc_me_type = lo_json_type_descr-&gt;absolute_name(lv_pos).
  ENDIF.

  sv_white_space = cl_abap_char_utilities=&gt;get_simple_spaces_for_cur_cp( ).

ENDMETHOD.                    &quot;class_constructor</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="COMPRESS" VERSION="1" LANGU="E" DESCRIPT="Skip empty elements" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="PRETTY_NAME" VERSION="1" LANGU="E" DESCRIPT="Pretty Print property names" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" PARVALUE="PRETTY_MODE-NONE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="ASSOC_ARRAYS" VERSION="1" LANGU="E" DESCRIPT="Serialize tables with unique keys as associative array" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="TS_AS_ISO8601" VERSION="1" LANGU="E" DESCRIPT="Dump timestamps as string in ISO8601 format" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="EXPAND_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="Expand named includes in structures" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-TRUE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="ASSOC_ARRAYS_OPT" VERSION="1" LANGU="E" DESCRIPT="Optimize rendering of name value maps" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="STRICT_MODE" VERSION="1" LANGU="E" DESCRIPT="Stop further processing on error" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="NUMC_AS_STRING" VERSION="1" LANGU="E" DESCRIPT="Serialize NUMC fields as strings" CMPTYPE="1" MTDTYPE="2" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="CONSTRUCTOR" SCONAME="NAME_MAPPINGS" VERSION="1" LANGU="E" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping Table" CMPTYPE="1" MTDTYPE="2" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="NAME_MAPPINGS" PAROPTIONL="X"/>
  <source>METHOD constructor.

  DATA: rtti TYPE REF TO cl_abap_classdescr,
        pair LIKE LINE OF name_mappings.

  mv_compress         = compress.
  mv_pretty_name    = pretty_name.
  mv_assoc_arrays   = assoc_arrays.
  mv_ts_as_iso8601  = ts_as_iso8601.
  mv_expand_includes  = expand_includes.
  mv_assoc_arrays_opt = assoc_arrays_opt.
  mv_strict_mode      = strict_mode.
  mv_numc_as_string   = numc_as_string.

  LOOP AT name_mappings INTO pair.
    TRANSLATE pair-abap TO UPPER CASE.
    INSERT pair INTO TABLE mt_name_mappings.
  ENDLOOP.

  INSERT LINES OF mt_name_mappings INTO TABLE mt_name_mappings_ex.

  IF mt_name_mappings IS NOT INITIAL.
    IF mv_pretty_name EQ pretty_mode-none.
      mv_pretty_name = pretty_mode-user.
    ELSEIF pretty_name EQ pretty_mode-low_case.
      mv_pretty_name = pretty_mode-user_low_case.
    ENDIF.
  ENDIF.

  rtti ?= cl_abap_classdescr=&gt;describe_by_object_ref( me ).
  IF rtti-&gt;absolute_name NE mc_me_type.
    mv_extended = c_bool-true.
  ENDIF.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" VERSION="1" LANGU="E" DESCRIPT="Serializes object" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="JSONX" VERSION="1" LANGU="E" DESCRIPT="JSON XString" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="PRETTY_NAME" VERSION="1" LANGU="E" DESCRIPT="Pretty Print property names" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" PARVALUE="PRETTY_MODE-NONE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="ASSOC_ARRAYS" VERSION="1" LANGU="E" DESCRIPT="Deserialize associative array as tables with unique keys" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="ASSOC_ARRAYS_OPT" VERSION="1" LANGU="E" DESCRIPT="Optimize rendering of name value maps" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="NAME_MAPPINGS" VERSION="1" LANGU="E" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping Table" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="NAME_MAPPINGS" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <source>METHOD deserialize.

  DATA: lo_json TYPE REF TO /ui2/cl_json.

  &quot; **********************************************************************
  &quot;! Usage examples and documentation can be found on SCN:
  &quot; http://wiki.scn.sap.com/wiki/display/Snippets/One+more+ABAP+to+JSON+Serializer+and+Deserializer
  &quot; **********************************************************************  &quot;

  IF json IS NOT INITIAL OR jsonx IS NOT INITIAL.

    CREATE OBJECT lo_json
      EXPORTING
        pretty_name  = pretty_name
        name_mappings    = name_mappings
        assoc_arrays     = assoc_arrays
        assoc_arrays_opt = assoc_arrays_opt.

    TRY .
        lo_json-&gt;deserialize_int( EXPORTING json = json jsonx = jsonx CHANGING data = data ).
      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDIF.

ENDMETHOD.                    &quot;deserialize</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE_INT" VERSION="1" LANGU="E" DESCRIPT="Deserializes ABAP object from JSON" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE_INT" SCONAME="JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE_INT" SCONAME="JSONX" VERSION="1" LANGU="E" DESCRIPT="JSON XString" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE_INT" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <exception CLSNAME="/UI2/CL_JSON" CMPNAME="DESERIALIZE_INT" SCONAME="CX_SY_MOVE_CAST_ERROR" VERSION="1" LANGU="E" DESCRIPT="May be fired only in case of STRICT_MODE = TRUE" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD deserialize_int.

  DATA: length    TYPE i,
        unescaped LIKE json.

  &quot; **********************************************************************
  &quot;! Usage examples and documentation can be found on SCN:
  &quot; http://wiki.scn.sap.com/wiki/display/Snippets/One+more+ABAP+to+JSON+Serializer+and+Deserializer
  &quot; **********************************************************************  &quot;

  IF json IS NOT INITIAL OR jsonx IS NOT INITIAL.

    IF jsonx IS NOT INITIAL.
      unescaped = raw_to_string( jsonx ).
    ELSE.
      unescaped = json.
    ENDIF.

    &quot; to eliminate numeric replacement calls for every single sting value, we do
    &quot; replacement over all JSON text, while this shall not destroy JSON structure
    REPLACE ALL OCCURRENCES OF `\r\n` IN unescaped WITH cl_abap_char_utilities=&gt;cr_lf.
    REPLACE ALL OCCURRENCES OF `\n`   IN unescaped WITH cl_abap_char_utilities=&gt;newline.
    REPLACE ALL OCCURRENCES OF `\t`   IN unescaped WITH cl_abap_char_utilities=&gt;horizontal_tab.
    &quot; REPLACE ALL OCCURRENCES OF `\f`   IN r_json WITH cl_abap_char_utilities=&gt;form_feed.
    &quot; REPLACE ALL OCCURRENCES OF `\b`   IN r_json WITH cl_abap_char_utilities=&gt;backspace.

    length = NUMOFCHAR( unescaped ).
    restore_type( EXPORTING json = unescaped length = length CHANGING data = data ).

  ENDIF.

ENDMETHOD.                    &quot;deserialize</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" VERSION="1" LANGU="E" DESCRIPT="Recursive conversion" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="COMPRESS" VERSION="1" LANGU="E" DESCRIPT="Skip empty elements" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Data descriptor" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="PRETTY_NAME" VERSION="1" LANGU="E" DESCRIPT="Pretty Print property names" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" PARVALUE="PRETTY_MODE-NONE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="ASSOC_ARRAYS" VERSION="1" LANGU="E" DESCRIPT="Serialize tables with unique keys as associative array" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="TS_AS_ISO8601" VERSION="1" LANGU="E" DESCRIPT="Dump timestamps as string in ISO8601 format" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD dump.

  DATA: lo_json TYPE REF TO /ui2/cl_json.

  CREATE OBJECT lo_json
    EXPORTING
      compress      = compress
      pretty_name   = pretty_name
      assoc_arrays  = assoc_arrays
      ts_as_iso8601 = ts_as_iso8601.

  r_json = lo_json-&gt;dump_int( data = data type_descr = type_descr ).

ENDMETHOD.                    &quot;dump</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_INT" VERSION="1" LANGU="E" DESCRIPT="Recursive conversion" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_INT" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_INT" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Data descriptor" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_INT" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD dump_int.

  DATA: lo_typedesc        TYPE REF TO cl_abap_typedescr,
        lo_elem_descr      TYPE REF TO cl_abap_elemdescr,
        lo_classdesc       TYPE REF TO cl_abap_classdescr,
        lo_structdesc      TYPE REF TO cl_abap_structdescr,
        lo_tabledescr      TYPE REF TO cl_abap_tabledescr,
        lt_symbols         TYPE t_t_symbol,
        lt_keys            LIKE lt_symbols,
        lt_properties      TYPE STANDARD TABLE OF string,
        lt_fields          TYPE STANDARD TABLE OF string,
        lo_obj_ref         TYPE REF TO object,
        lo_data_ref        TYPE REF TO data,
        ls_skip_key        TYPE LINE OF abap_keydescr_tab,
        lv_array_opt       TYPE abap_bool,
        lv_prop_name       TYPE string,
        lv_keyval          TYPE string,
        lv_itemval         TYPE string.

  FIELD-SYMBOLS: &lt;line&gt;    TYPE ANY,
                 &lt;value&gt;   TYPE ANY,
                 &lt;data&gt;    TYPE data,
                 &lt;key&gt;     TYPE LINE OF abap_keydescr_tab,
                 &lt;symbol&gt;  LIKE LINE OF lt_symbols,
                 &lt;table&gt;   TYPE ANY TABLE.

  &quot; we need here macro instead of method calls because of the performance reasons.
  &quot; based on SAT measurements.

  CASE type_descr-&gt;kind.
    WHEN cl_abap_typedescr=&gt;kind_ref.

      IF data IS INITIAL.
        r_json = `null`.                                    &quot;#EC NOTEXT
      ELSEIF type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
        lo_data_ref ?= data.
        lo_typedesc = cl_abap_typedescr=&gt;describe_by_data_ref( lo_data_ref ).
        ASSIGN lo_data_ref-&gt;* TO &lt;data&gt;.
        r_json = dump_int( data = &lt;data&gt; type_descr = lo_typedesc ).
      ELSE.
        lo_obj_ref ?= data.
        lo_classdesc ?= cl_abap_typedescr=&gt;describe_by_object_ref( lo_obj_ref ).
        lt_symbols = get_symbols( type_descr = lo_classdesc object = lo_obj_ref ).
        r_json = dump_symbols( lt_symbols ).
      ENDIF.

    WHEN cl_abap_typedescr=&gt;kind_elem.
      lo_elem_descr ?= type_descr.
      dump_type data lo_elem_descr r_json.

    WHEN cl_abap_typedescr=&gt;kind_struct.

      lo_structdesc ?= type_descr.
      GET REFERENCE OF data INTO lo_data_ref.
      lt_symbols = get_symbols( type_descr = lo_structdesc data = lo_data_ref ).
      r_json = dump_symbols( lt_symbols ).

    WHEN cl_abap_typedescr=&gt;kind_table.

      lo_tabledescr ?= type_descr.
      lo_typedesc = lo_tabledescr-&gt;get_table_line_type( ).

      ASSIGN data TO &lt;table&gt;.

      &quot; optimization for structured tables
      IF lo_typedesc-&gt;kind EQ cl_abap_typedescr=&gt;kind_struct.
        lo_structdesc ?= lo_typedesc.
        CREATE DATA lo_data_ref LIKE LINE OF &lt;table&gt;.
        ASSIGN lo_data_ref-&gt;* TO &lt;line&gt;.
        lt_symbols = get_symbols( type_descr = lo_structdesc data = lo_data_ref ).

        &quot; here we have differentiation of output of simple table to JSON array
        &quot; and sorted or hashed table with unique key into JSON associative array
        IF lo_tabledescr-&gt;has_unique_key IS NOT INITIAL AND mv_assoc_arrays IS NOT INITIAL.

          IF lo_tabledescr-&gt;key_defkind EQ lo_tabledescr-&gt;keydefkind_user.
            LOOP AT lo_tabledescr-&gt;key ASSIGNING &lt;key&gt;.
              READ TABLE lt_symbols WITH KEY name = &lt;key&gt;-name ASSIGNING &lt;symbol&gt;.
              APPEND &lt;symbol&gt; TO lt_keys.
            ENDLOOP.
          ENDIF.

          IF LINES( lo_tabledescr-&gt;key ) EQ 1.
            READ TABLE lo_tabledescr-&gt;key INDEX 1 INTO ls_skip_key.
            DELETE lt_symbols WHERE name EQ ls_skip_key-name.
            &quot; remove object wrapping for simple name-value tables
            IF mv_assoc_arrays_opt EQ abap_true AND LINES( lt_symbols ) EQ 1.
              lv_array_opt = abap_true.
            ENDIF.
          ENDIF.

          LOOP AT &lt;table&gt; INTO &lt;line&gt;.
            CLEAR: lt_fields, lv_prop_name.
            LOOP AT lt_symbols ASSIGNING &lt;symbol&gt;.
              ASSIGN &lt;symbol&gt;-value-&gt;* TO &lt;value&gt;.
              IF mv_compress IS INITIAL OR &lt;value&gt; IS NOT INITIAL OR &lt;symbol&gt;-compressable EQ abap_false.
                IF &lt;symbol&gt;-type-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
                  lo_elem_descr ?= &lt;symbol&gt;-type.
                  dump_type &lt;value&gt; lo_elem_descr lv_itemval.
                ELSE.
                  lv_itemval = dump_int( data = &lt;value&gt; type_descr = &lt;symbol&gt;-type ).
                ENDIF.
                IF lv_array_opt EQ abap_false.
                  CONCATENATE &lt;symbol&gt;-header lv_itemval INTO lv_itemval.
                ENDIF.
                APPEND lv_itemval TO lt_fields.
              ENDIF.
            ENDLOOP.

            IF lo_tabledescr-&gt;key_defkind EQ lo_tabledescr-&gt;keydefkind_user.
              LOOP AT lt_keys ASSIGNING &lt;symbol&gt;.
                ASSIGN &lt;symbol&gt;-value-&gt;* TO &lt;value&gt;.
                MOVE &lt;value&gt; TO lv_keyval.
                CONDENSE lv_keyval.
                IF lv_prop_name IS NOT INITIAL.
                  CONCATENATE lv_prop_name mc_key_separator lv_keyval INTO lv_prop_name.
                ELSE.
                  lv_prop_name = lv_keyval.
                ENDIF.
              ENDLOOP.
            ELSE.
              LOOP AT lt_symbols ASSIGNING &lt;symbol&gt;.
                ASSIGN &lt;symbol&gt;-value-&gt;* TO &lt;value&gt;.
                MOVE &lt;value&gt; TO lv_keyval.
                CONDENSE lv_keyval.
                IF lv_prop_name IS NOT INITIAL.
                  CONCATENATE lv_prop_name mc_key_separator lv_keyval INTO lv_prop_name.
                ELSE.
                  lv_prop_name = lv_keyval.
                ENDIF.
              ENDLOOP.
            ENDIF.

            CONCATENATE LINES OF lt_fields INTO lv_itemval SEPARATED BY `,`.
            IF lv_array_opt EQ abap_false.
              CONCATENATE `&quot;` lv_prop_name `&quot;:{` lv_itemval `}` INTO lv_itemval.
            ELSE.
              CONCATENATE `&quot;` lv_prop_name `&quot;:` lv_itemval `` INTO lv_itemval.
            ENDIF.
            APPEND lv_itemval TO lt_properties.

          ENDLOOP.

          CONCATENATE LINES OF lt_properties INTO r_json SEPARATED BY `,`.
          CONCATENATE `{` r_json `}` INTO r_json.

        ELSE.

          LOOP AT &lt;table&gt; INTO &lt;line&gt;.
            CLEAR lt_fields.
            LOOP AT lt_symbols ASSIGNING &lt;symbol&gt;.
              ASSIGN &lt;symbol&gt;-value-&gt;* TO &lt;value&gt;.
              IF mv_compress IS INITIAL OR &lt;value&gt; IS NOT INITIAL OR &lt;symbol&gt;-compressable EQ abap_false.
                IF &lt;symbol&gt;-type-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
                  lo_elem_descr ?= &lt;symbol&gt;-type.
                  dump_type &lt;value&gt; lo_elem_descr lv_itemval.
                ELSE.
                  lv_itemval = dump_int( data = &lt;value&gt; type_descr = &lt;symbol&gt;-type ).
                ENDIF.
                CONCATENATE &lt;symbol&gt;-header lv_itemval INTO lv_itemval.
                APPEND lv_itemval TO lt_fields.
              ENDIF.
            ENDLOOP.

            CONCATENATE LINES OF lt_fields INTO lv_itemval SEPARATED BY `,`.
            CONCATENATE `{` lv_itemval `}` INTO lv_itemval.
            APPEND lv_itemval TO lt_properties.
          ENDLOOP.

          CONCATENATE LINES OF lt_properties INTO r_json SEPARATED BY `,`.
          CONCATENATE `[` r_json `]` INTO r_json.

        ENDIF.
      ELSE.
        LOOP AT &lt;table&gt; ASSIGNING &lt;value&gt;.
          lv_itemval = dump_int( data = &lt;value&gt; type_descr = lo_typedesc ).
          APPEND lv_itemval TO lt_properties.
        ENDLOOP.

        CONCATENATE LINES OF lt_properties INTO r_json SEPARATED BY `,`.
        CONCATENATE `[` r_json `]` INTO r_json.
      ENDIF.

  ENDCASE.

ENDMETHOD.                    &quot;dump</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_SYMBOLS" VERSION="1" LANGU="E" DESCRIPT="Dump to JSON symbol table" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDFINAL="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_SYMBOLS" SCONAME="IT_SYMBOLS" VERSION="1" LANGU="E" DESCRIPT="Standard table of T_S_SYMBOL" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="T_T_SYMBOL"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_SYMBOLS" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD dump_symbols.

  DATA: lv_properties      TYPE STANDARD TABLE OF string,
        lv_itemval         TYPE string.

  FIELD-SYMBOLS: &lt;value&gt;   TYPE ANY,
                 &lt;symbol&gt;  LIKE LINE OF it_symbols.

  LOOP AT it_symbols ASSIGNING &lt;symbol&gt;.
    ASSIGN &lt;symbol&gt;-value-&gt;* TO &lt;value&gt;.
    IF mv_compress IS INITIAL OR &lt;value&gt; IS NOT INITIAL OR &lt;symbol&gt;-compressable EQ abap_false.
      lv_itemval = dump_int( data = &lt;value&gt; type_descr = &lt;symbol&gt;-type ).
      CONCATENATE &lt;symbol&gt;-header lv_itemval INTO lv_itemval.
      APPEND lv_itemval TO lv_properties.
    ENDIF.
  ENDLOOP.

  CONCATENATE LINES OF lv_properties INTO r_json SEPARATED BY `,`.
  CONCATENATE `{` r_json `}` INTO r_json.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE" VERSION="1" LANGU="E" DESCRIPT="Dumps elementary type to string" EXPOSURE="1" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Data descriptor" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_ELEMDESCR"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD dump_type.

  CASE type_descr-&gt;type_kind.
    WHEN cl_abap_typedescr=&gt;typekind_float OR cl_abap_typedescr=&gt;typekind_int OR cl_abap_typedescr=&gt;typekind_int1 OR
         cl_abap_typedescr=&gt;typekind_int2 OR cl_abap_typedescr=&gt;typekind_packed OR `8`. &quot; TYPEKIND_INT8 -&gt; &apos;8&apos; only from 7.40

      IF type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_packed AND mv_ts_as_iso8601 EQ c_bool-true AND type_descr-&gt;absolute_name CP `\TYPE=TIMESTAMP*`.
        IF data IS INITIAL.
          r_json = `&quot;&quot;`.
        ELSE.
          MOVE data TO r_json.
          IF type_descr-&gt;absolute_name EQ `\TYPE=TIMESTAMP`.
            CONCATENATE `&quot;` r_json(4) `-` r_json+4(2) `-` r_json+6(2) `T` r_json+8(2) `:` r_json+10(2) `:` r_json+12(2) `.0000000Z&quot;`  INTO r_json.
          ELSEIF type_descr-&gt;absolute_name EQ `\TYPE=TIMESTAMPL`.
            CONCATENATE `&quot;` r_json(4) `-` r_json+4(2) `-` r_json+6(2) `T` r_json+8(2) `:` r_json+10(2) `:` r_json+12(2) `.` r_json+15(7) `Z&quot;`  INTO r_json.
          ENDIF.
        ENDIF.
      ELSEIF data IS INITIAL.
        r_json = `0`.
      ELSE.
        MOVE data TO r_json.
        IF data LT 0.
          IF type_descr-&gt;type_kind &lt;&gt; cl_abap_typedescr=&gt;typekind_float. &quot;float: sign is already at the beginning
            SHIFT r_json RIGHT CIRCULAR.
          ENDIF.
        ELSE.
          CONDENSE r_json.
        ENDIF.
      ENDIF.
    WHEN cl_abap_typedescr=&gt;typekind_num.
      IF mv_numc_as_string EQ abap_true.
        IF data IS INITIAL.
          r_json = `&quot;&quot;`.
        ELSE.
          CONCATENATE `&quot;` data `&quot;` INTO r_json.
        ENDIF.
      ELSE.
        IF data IS INITIAL.
        r_json = `0`.
      ELSE.
        MOVE data TO r_json.
        SHIFT r_json LEFT DELETING LEADING ` 0`.
        ENDIF.
      ENDIF.
    WHEN cl_abap_typedescr=&gt;typekind_string OR cl_abap_typedescr=&gt;typekind_csequence OR cl_abap_typedescr=&gt;typekind_clike.
      IF data IS INITIAL.
        r_json = `&quot;&quot;`.
      ELSEIF type_descr-&gt;absolute_name EQ mc_json_type.
        r_json = data.
      ELSE.
        r_json = escape( data ).
        CONCATENATE `&quot;` r_json `&quot;` INTO r_json.
      ENDIF.
    WHEN cl_abap_typedescr=&gt;typekind_xstring OR cl_abap_typedescr=&gt;typekind_hex.
      IF data IS INITIAL.
        r_json = `&quot;&quot;`.
      ELSE.
        r_json = xstring_to_string( data ).
        r_json = escape( r_json ).
        CONCATENATE `&quot;` r_json `&quot;` INTO r_json.
      ENDIF.
    WHEN cl_abap_typedescr=&gt;typekind_char.
      IF type_descr-&gt;output_length EQ 1 AND mc_bool_types CS type_descr-&gt;absolute_name.
        IF data EQ c_bool-true.
          r_json = `true`.                                &quot;#EC NOTEXT
        ELSEIF mc_bool_3state CS type_descr-&gt;absolute_name AND data IS INITIAL.
          r_json = `null`.                                &quot;#EC NOTEXT
        ELSE.
          r_json = `false`.                               &quot;#EC NOTEXT
        ENDIF.
      ELSE.
        r_json = escape( data ).
        CONCATENATE `&quot;` r_json `&quot;` INTO r_json.
      ENDIF.
    WHEN cl_abap_typedescr=&gt;typekind_date.
      CONCATENATE `&quot;` data(4) `-` data+4(2) `-` data+6(2) `&quot;` INTO r_json.
    WHEN cl_abap_typedescr=&gt;typekind_time.
      CONCATENATE `&quot;` data(2) `:` data+2(2) `:` data+4(2) `&quot;` INTO r_json.
    WHEN OTHERS.
      IF data IS INITIAL.
        r_json = `null`.                                  &quot;#EC NOTEXT
      ELSE.
        MOVE data TO r_json.
      ENDIF.
  ENDCASE.

ENDMETHOD.                    &quot;dump_type</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE_EX" VERSION="1" LANGU="E" DESCRIPT="Dumps elementary type to string (no type description needed)" EXPOSURE="1" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE_EX" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="DUMP_TYPE_EX" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD dump_type_ex.

  DATA: lo_descr TYPE REF TO cl_abap_elemdescr.
  lo_descr ?= cl_abap_typedescr=&gt;describe_by_data( data ).
  r_json = dump_type( data = data type_descr = lo_descr ).

ENDMETHOD.                    &quot;DUMP_TYPE_EX</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="EDM_DATETIME_TO_TS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="EDM_DATETIME_TO_TS" SCONAME="TICKS" VERSION="1" LANGU="E" DESCRIPT="Seconds elapsed from 01.01.1970 00:00:00" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="EDM_DATETIME_TO_TS" SCONAME="OFFSET" VERSION="1" LANGU="E" DESCRIPT="Offset in minutes (positive/negative)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="EDM_DATETIME_TO_TS" SCONAME="TYPEKIND" VERSION="1" LANGU="E" DESCRIPT="Receiving data type" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_TYPEKIND"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="EDM_DATETIME_TO_TS" SCONAME="R_DATA" VERSION="1" LANGU="E" DESCRIPT="Typekind normalized return value" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD edm_datetime_to_ts.

  DATA: lv_ticks     TYPE p,
        lv_timestamp TYPE timestamp VALUE `19700101000000`.

  lv_ticks     = ticks.
  lv_ticks     = lv_ticks / 1000. &quot; in seconds
  lv_timestamp = cl_abap_tstmp=&gt;add( tstmp = lv_timestamp secs = lv_ticks ).

  IF offset IS NOT INITIAL.
    lv_ticks = offset+1.
    lv_ticks = lv_ticks * 60. &quot;offset is in minutes
    IF offset(1) = &apos;+&apos;.
      lv_timestamp = cl_abap_tstmp=&gt;subtractsecs( tstmp = lv_timestamp secs = lv_ticks ).
    ELSE.
      lv_timestamp = cl_abap_tstmp=&gt;add( tstmp = lv_timestamp secs = lv_ticks ).
    ENDIF.
  ENDIF.

  CASE typekind.
    WHEN cl_abap_typedescr=&gt;typekind_time.
      r_data = lv_timestamp.
      r_data = r_data+8(6).
    WHEN cl_abap_typedescr=&gt;typekind_date.
      r_data = lv_timestamp.
      r_data = r_data(8).
    WHEN cl_abap_typedescr=&gt;typekind_packed.
      r_data = lv_timestamp.
  ENDCASE.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="ESCAPE" VERSION="1" LANGU="E" DESCRIPT="Escapes JSON String" EXPOSURE="1" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="ESCAPE" SCONAME="IN" VERSION="1" LANGU="E" DESCRIPT="Text to escape" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="ESCAPE" SCONAME="OUT" VERSION="1" LANGU="E" DESCRIPT="Processed text" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD escape.

  MOVE in TO out.

  REPLACE ALL OCCURRENCES OF `\` IN out WITH `\\`.
  REPLACE ALL OCCURRENCES OF `&quot;` IN out WITH `\&quot;`.

ENDMETHOD.                    &quot;escape</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE" VERSION="1" LANGU="E" DESCRIPT="Generates ABAP object from JSON" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE" SCONAME="PRETTY_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" PARVALUE="PRETTY_MODE-NONE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE" SCONAME="NAME_MAPPINGS" VERSION="1" LANGU="E" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping Table" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="NAME_MAPPINGS" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE" SCONAME="RR_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD generate.

  DATA: lo_json   TYPE REF TO /ui2/cl_json,
        lv_json   LIKE json.

  lv_json = json.

  REPLACE ALL OCCURRENCES OF `\r\n` IN lv_json WITH cl_abap_char_utilities=&gt;cr_lf.
  REPLACE ALL OCCURRENCES OF `\n`   IN lv_json WITH cl_abap_char_utilities=&gt;newline.
  REPLACE ALL OCCURRENCES OF `\t`   IN lv_json WITH cl_abap_char_utilities=&gt;horizontal_tab.

  CREATE OBJECT lo_json
    EXPORTING
      pretty_name      = pretty_name
      name_mappings    = name_mappings
      assoc_arrays     = c_bool-true
      assoc_arrays_opt = c_bool-true.

  TRY .
      rr_data = lo_json-&gt;generate_int( lv_json ).
    CATCH cx_sy_move_cast_error.
  ENDTRY.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT" VERSION="1" LANGU="E" DESCRIPT="Generates ABAP object from JSON" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT" SCONAME="RR_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD generate_int.

  TYPES: BEGIN OF ts_field,
          name  TYPE string,
          value TYPE json,
        END OF ts_field.

  DATA: length TYPE i,
        offset TYPE i.

  DATA: lt_json   TYPE STANDARD TABLE OF json WITH DEFAULT KEY,
        lv_json   LIKE LINE OF lt_json,
        lv_comp_name  TYPE abap_compname,
        lt_fields     TYPE SORTED TABLE OF ts_field WITH UNIQUE KEY name,
        lo_type       TYPE REF TO cl_abap_datadescr,
        lt_comp      TYPE abap_component_tab,
        lt_names     TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line,
        cache        LIKE LINE OF mt_name_mappings_ex,
        ls_comp   LIKE LINE OF lt_comp.

  FIELD-SYMBOLS: &lt;data&gt;   TYPE ANY,
                 &lt;struct&gt; TYPE ANY,
                 &lt;field&gt;  LIKE LINE OF lt_fields,
                 &lt;table&gt;  TYPE STANDARD TABLE,
                 &lt;cache&gt;  LIKE LINE OF mt_name_mappings_ex.

  length = NUMOFCHAR( json ).

  eat_white.

  CASE json+offset(1).
    WHEN `{`.&quot;result must be a structure
      restore_type( EXPORTING json = json length = length CHANGING  data = lt_fields ).
      IF lt_fields IS NOT INITIAL.
        ls_comp-type = cl_abap_refdescr=&gt;get_ref_to_data( ).
        LOOP AT lt_fields ASSIGNING &lt;field&gt;.
          READ TABLE mt_name_mappings_ex WITH TABLE KEY json = &lt;field&gt;-name ASSIGNING &lt;cache&gt;.
          IF sy-subrc IS INITIAL.
            ls_comp-name = &lt;cache&gt;-abap.
          ELSE.
            cache-json = ls_comp-name = &lt;field&gt;-name.
          TRANSLATE ls_comp-name USING `/_:_~_._-_`. &quot; remove characters not allowed in component names
          IF mv_pretty_name EQ pretty_mode-camel_case OR mv_pretty_name EQ pretty_mode-extended.
            REPLACE ALL OCCURRENCES OF REGEX `([a-z])([A-Z])` IN ls_comp-name WITH `$1_$2`. &quot;#EC NOTEXT
          ENDIF.
          TRANSLATE ls_comp-name TO UPPER CASE.
            cache-abap = ls_comp-name = lv_comp_name = ls_comp-name. &quot; truncate by allowed field name length
            INSERT cache INTO TABLE mt_name_mappings_ex.
          ENDIF.
          INSERT ls_comp-name INTO TABLE lt_names.
          IF sy-subrc IS INITIAL.
            APPEND ls_comp TO lt_comp.
          ELSE.
            DELETE lt_fields.
          ENDIF.
        ENDLOOP.
        TRY.
            lo_type = cl_abap_structdescr=&gt;create( p_components = lt_comp p_strict = c_bool-false ).
            CREATE DATA rr_data TYPE HANDLE lo_type.
            ASSIGN rr_data-&gt;* TO &lt;struct&gt;.
            LOOP AT lt_fields ASSIGNING &lt;field&gt;.
              ASSIGN COMPONENT sy-tabix OF STRUCTURE &lt;struct&gt; TO &lt;data&gt;.
              &lt;data&gt; = generate_int( &lt;field&gt;-value ).
            ENDLOOP.
          CATCH cx_sy_create_data_error cx_sy_struct_creation.
        ENDTRY.
      ENDIF.
    WHEN `[`.&quot;result must be a table of ref
      restore_type( EXPORTING json = json length = length CHANGING  data = lt_json ).
      CREATE DATA rr_data TYPE TABLE OF REF TO data.
      ASSIGN rr_data-&gt;* TO &lt;table&gt;.
      LOOP AT lt_json INTO lv_json.
        APPEND INITIAL LINE TO &lt;table&gt; ASSIGNING &lt;data&gt;.
        &lt;data&gt; = generate_int( lv_json ).
      ENDLOOP.
    WHEN OTHERS.
      IF json+offset(1) EQ `&quot;`.
        CREATE DATA rr_data TYPE string.
      ELSEIF json+offset(1) CA `-0123456789.`.
        IF json+offset CS &apos;.&apos;.
          CREATE DATA rr_data TYPE f.
        ELSEIF length GT 9.
          CREATE DATA rr_data TYPE p.
        ELSE.
          CREATE DATA rr_data TYPE i.
        ENDIF.
      ELSEIF json+offset EQ `true` OR json+offset EQ `false`.
        CREATE DATA rr_data TYPE abap_bool.
      ENDIF.
      IF rr_data IS BOUND.
        ASSIGN rr_data-&gt;* TO &lt;data&gt;.
        restore_type( EXPORTING json = json length = length CHANGING  data = &lt;data&gt; ).
      ENDIF.
  ENDCASE.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT_EX" VERSION="1" LANGU="E" DESCRIPT="Generates ABAP object from JSON" EXPOSURE="1" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDFINAL="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT_EX" SCONAME="JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT_EX" SCONAME="LENGTH" VERSION="1" LANGU="E" DESCRIPT="Length of JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT_EX" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GENERATE_INT_EX" SCONAME="OFFSET" VERSION="1" LANGU="E" DESCRIPT="Offset in JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <source>METHOD generate_int_ex.

  DATA: lv_assoc_arrays     LIKE mv_assoc_arrays,
        lv_assoc_arrays_opt LIKE mv_assoc_arrays_opt,
        lv_mark             LIKE offset,
        lv_match            LIKE lv_mark,
        lv_json             TYPE /ui2/cl_json=&gt;json.

  lv_mark = offset.
  restore_type( EXPORTING json = json length = length CHANGING offset = offset ).
  lv_match = offset - lv_mark.
  lv_json = json+lv_mark(lv_match).

  lv_assoc_arrays     = mv_assoc_arrays.
  lv_assoc_arrays_opt = mv_assoc_arrays_opt.

  mv_assoc_arrays     = abap_true.
  mv_assoc_arrays_opt = abap_true.

  data = generate_int( lv_json ).

  mv_assoc_arrays = lv_assoc_arrays.
  mv_assoc_arrays_opt = lv_assoc_arrays_opt.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="GET_FIELDS" VERSION="1" LANGU="E" DESCRIPT="Prepares structure fields cache" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDFINAL="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_FIELDS" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_FIELDS" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Structure reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_FIELDS" SCONAME="OBJECT" VERSION="1" LANGU="E" DESCRIPT="Object reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="OBJECT" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_FIELDS" SCONAME="RT_FIELDS" VERSION="1" LANGU="E" DESCRIPT="Field cache" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="T_T_FIELD_CACHE"/>
  <source>METHOD get_fields.

  DATA: lt_symbols      TYPE t_t_symbol,
        lv_name     TYPE char128,
        ls_field    LIKE LINE OF rt_fields.

  FIELD-SYMBOLS: &lt;sym&gt;   LIKE LINE OF lt_symbols,
                 &lt;cache&gt; LIKE LINE OF mt_name_mappings.

  lt_symbols = get_symbols( type_descr = type_descr data = data object = object include_aliases = abap_true ).

  LOOP AT lt_symbols ASSIGNING &lt;sym&gt; WHERE read_only EQ abap_false.
    ls_field-name  = &lt;sym&gt;-name.
    ls_field-type  = &lt;sym&gt;-type.
    ls_field-value = &lt;sym&gt;-value.

    &quot; insert as UPPER CASE
    INSERT ls_field INTO TABLE rt_fields.

    &quot; insert as lower case
    TRANSLATE ls_field-name TO LOWER CASE.
    INSERT ls_field INTO TABLE rt_fields.

    &quot; as pretty printed
    IF mv_pretty_name NE pretty_mode-none AND mv_pretty_name NE pretty_mode-low_case.
      format_name &lt;sym&gt;-name mv_pretty_name ls_field-name.
      INSERT ls_field INTO TABLE rt_fields.
      &quot; let us check for not well formed canelCase to be compatible with old logic
      lv_name = ls_field-name.
      TRANSLATE lv_name(1) TO UPPER CASE.
      ls_field-name = lv_name.
      INSERT ls_field INTO TABLE rt_fields.
    ENDIF.

  ENDLOOP.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" VERSION="1" LANGU="E" DESCRIPT="Alternative impl. of CL_ABAP_STRUCTDESCR=&gt;GET_SYMBOLS_TAB" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDFINAL="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Structure reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" SCONAME="OBJECT" VERSION="1" LANGU="E" DESCRIPT="Object reference" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="OBJECT" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" SCONAME="INCLUDE_ALIASES" VERSION="1" LANGU="E" DESCRIPT="Include alias fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="GET_SYMBOLS" SCONAME="RESULT" VERSION="1" LANGU="E" DESCRIPT="Standard table of T_S_SYMBOL" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="T_T_SYMBOL"/>
  <source>METHOD get_symbols.

  DATA: comp_tab TYPE cl_abap_structdescr=&gt;component_table,
        symb_tab LIKE result,
        symb     LIKE LINE OF symb_tab,
        class_descr   TYPE REF TO cl_abap_classdescr,
        struct_descr  TYPE REF TO cl_abap_structdescr.

  FIELD-SYMBOLS: &lt;comp&gt;  LIKE LINE OF comp_tab,
                 &lt;attr&gt;  LIKE LINE OF cl_abap_objectdescr=&gt;attributes,
                 &lt;cache&gt; LIKE LINE OF mt_name_mappings,
                 &lt;field&gt; TYPE any.

  IF type_descr-&gt;kind EQ cl_abap_typedescr=&gt;kind_struct.

    struct_descr ?= type_descr.
  comp_tab = struct_descr-&gt;get_components( ).

  LOOP AT comp_tab ASSIGNING &lt;comp&gt;.
      IF &lt;comp&gt;-name IS NOT INITIAL AND
        ( &lt;comp&gt;-as_include EQ abap_false OR include_aliases EQ abap_true OR mv_expand_includes EQ abap_false ).
        symb-name = &lt;comp&gt;-name.
        symb-type = &lt;comp&gt;-type.
        IF data IS BOUND.
          is_compressable symb-type symb-name symb-compressable.
          ASSIGN data-&gt;(symb-name) TO &lt;field&gt;.
          GET REFERENCE OF &lt;field&gt; INTO symb-value.
          format_name symb-name mv_pretty_name symb-header.
        CONCATENATE `&quot;` symb-header  `&quot;:` INTO symb-header.
        ENDIF.
        APPEND symb TO result.
      ENDIF.
      IF &lt;comp&gt;-as_include EQ abap_true AND mv_expand_includes EQ abap_true.
        struct_descr ?= &lt;comp&gt;-type.
        symb_tab = get_symbols( type_descr = struct_descr include_aliases = include_aliases ).
        LOOP AT symb_tab INTO symb.
          CONCATENATE symb-name &lt;comp&gt;-suffix INTO symb-name.
          IF data IS BOUND.
            is_compressable symb-type symb-name symb-compressable.
        ASSIGN data-&gt;(symb-name) TO &lt;field&gt;.
        GET REFERENCE OF &lt;field&gt; INTO symb-value.
        format_name symb-name mv_pretty_name symb-header.
      CONCATENATE `&quot;` symb-header  `&quot;:` INTO symb-header.
          ENDIF.
          APPEND symb TO result.
        ENDLOOP.
    ENDIF.
    ENDLOOP.

  ELSEIF type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_class.

    class_descr ?= type_descr.
    LOOP AT class_descr-&gt;attributes ASSIGNING &lt;attr&gt; WHERE is_constant IS INITIAL AND alias_for IS INITIAL AND
      ( is_interface IS INITIAL OR type_kind NE cl_abap_typedescr=&gt;typekind_oref ).
      ASSIGN object-&gt;(&lt;attr&gt;-name) TO &lt;field&gt;.
      CHECK sy-subrc IS INITIAL. &quot; we can only assign to public attributes
      symb-name = &lt;attr&gt;-name.
      symb-read_only = &lt;attr&gt;-is_read_only.
      symb-type = class_descr-&gt;get_attribute_type( &lt;attr&gt;-name ).
      is_compressable symb-type symb-name symb-compressable.
      GET REFERENCE OF &lt;field&gt; INTO symb-value.
      format_name symb-name mv_pretty_name symb-header.
      CONCATENATE `&quot;` symb-header  `&quot;:` INTO symb-header.
      APPEND symb TO result.
    ENDLOOP.

  ENDIF.

ENDMETHOD.                    &quot;GET_SYMBOLS</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="IS_COMPRESSABLE" VERSION="1" LANGU="E" DESCRIPT="Check if initial field shall be compressed" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="IS_COMPRESSABLE" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Value type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="IS_COMPRESSABLE" SCONAME="NAME" VERSION="1" LANGU="E" DESCRIPT="Fielld name" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="IS_COMPRESSABLE" SCONAME="RV_COMPRESS" VERSION="1" LANGU="E" DESCRIPT="Initial value shall be compressed" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  <source>METHOD is_compressable.
  rv_compress = abap_true.
ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME" VERSION="1" LANGU="E" DESCRIPT="PrettyPrint names" EXPOSURE="1" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME" SCONAME="IN" VERSION="1" LANGU="E" DESCRIPT="Text to pretty print" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME" SCONAME="OUT" VERSION="1" LANGU="E" DESCRIPT="Processed" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD PRETTY_NAME.

  DATA: tokens TYPE TABLE OF char128,
        cache  LIKE LINE OF mt_name_mappings.

  FIELD-SYMBOLS: &lt;token&gt; LIKE LINE OF tokens,
                 &lt;cache&gt; LIKE LINE OF mt_name_mappings.

  READ TABLE mt_name_mappings WITH TABLE KEY abap = in ASSIGNING &lt;cache&gt;.
  IF sy-subrc IS INITIAL.
    out = &lt;cache&gt;-json.
  ELSE.
    out = in.

    REPLACE ALL OCCURRENCES OF `__` IN out WITH `*`.

    TRANSLATE out TO LOWER CASE.
    TRANSLATE out USING `/_:_~_`.
    SPLIT out AT `_` INTO TABLE tokens.
    LOOP AT tokens ASSIGNING &lt;token&gt; FROM 2.
      TRANSLATE &lt;token&gt;(1) TO UPPER CASE.
    ENDLOOP.

    CONCATENATE LINES OF tokens INTO out.
    REPLACE ALL OCCURRENCES OF `*` IN out WITH `_`.

    cache-abap  = in.
    cache-json = out.
    INSERT cache INTO TABLE mt_name_mappings.
    INSERT cache INTO TABLE mt_name_mappings_ex.
  ENDIF.

ENDMETHOD.                    &quot;pretty_name</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME_EX" VERSION="1" LANGU="E" DESCRIPT="PrettyPrint names in extended form" EXPOSURE="1" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME_EX" SCONAME="IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="PRETTY_NAME_EX" SCONAME="OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD PRETTY_NAME_EX.

  DATA: tokens TYPE TABLE OF char128,
        cache     LIKE LINE OF mt_name_mappings,
        lt_match  TYPE match_result_tab.

  FIELD-SYMBOLS: &lt;token&gt;      LIKE LINE OF tokens,
                 &lt;cache&gt;      LIKE LINE OF mt_name_mappings,
                 &lt;match&gt;      LIKE LINE OF lt_match,
                 &lt;sub_match&gt;  TYPE LINE OF submatch_result_tab.

  READ TABLE mt_name_mappings WITH TABLE KEY abap = in ASSIGNING &lt;cache&gt;.
  IF sy-subrc IS INITIAL.
    out = &lt;cache&gt;-json.
  ELSE.
    out = in.


    TRANSLATE out TO LOWER CASE.
    TRANSLATE out USING `/_:_~_`.

    REPLACE ALL OCCURRENCES OF `__e__` IN out WITH `!`.
    REPLACE ALL OCCURRENCES OF `__n__` IN out WITH `#`.
    REPLACE ALL OCCURRENCES OF `__d__` IN out WITH `$`.
    REPLACE ALL OCCURRENCES OF `__p__` IN out WITH `%`.
    REPLACE ALL OCCURRENCES OF `__m__` IN out WITH `&amp;`.
    REPLACE ALL OCCURRENCES OF `__s__` IN out WITH `*`.
    REPLACE ALL OCCURRENCES OF `__h__` IN out WITH `-`.
    REPLACE ALL OCCURRENCES OF `__t__` IN out WITH `~`.
    REPLACE ALL OCCURRENCES OF `__l__` IN out WITH `/`.
    REPLACE ALL OCCURRENCES OF `__c__` IN out WITH `:`.
    REPLACE ALL OCCURRENCES OF `__v__` IN out WITH `|`.
    REPLACE ALL OCCURRENCES OF `__a__` IN out WITH `@`.
    REPLACE ALL OCCURRENCES OF `__o__` IN out WITH `.`.
    REPLACE ALL OCCURRENCES OF `___` IN out WITH `.`.

    REPLACE ALL OCCURRENCES OF `__` IN out WITH `&quot;`.

    SPLIT out AT `_` INTO TABLE tokens.
    LOOP AT tokens ASSIGNING &lt;token&gt; FROM 2.
      TRANSLATE &lt;token&gt;(1) TO UPPER CASE.
    ENDLOOP.

    CONCATENATE LINES OF tokens INTO out.
    REPLACE ALL OCCURRENCES OF `&quot;` IN out WITH `_`.

    cache-abap  = in.
    cache-json = out.
    INSERT cache INTO TABLE mt_name_mappings.
    INSERT cache INTO TABLE mt_name_mappings_ex.
  ENDIF.

ENDMETHOD.                    &quot;pretty_name_ex</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="RAW_TO_STRING" VERSION="1" LANGU="E" DESCRIPT="Converts XSTRING to STRING" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RAW_TO_STRING" SCONAME="IV_XSTRING" VERSION="1" LANGU="E" DESCRIPT="Input XString" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RAW_TO_STRING" SCONAME="IV_ENCODING" VERSION="1" LANGU="E" DESCRIPT="Encoding for conversion" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ENCODING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RAW_TO_STRING" SCONAME="RV_STRING" VERSION="1" LANGU="E" DESCRIPT="Coverted String" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD raw_to_string.

  DATA: lv_output_length TYPE i,
        lt_binary_tab    TYPE STANDARD TABLE OF sdokcntbin.

  CALL FUNCTION &apos;SCMS_XSTRING_TO_BINARY&apos;
    EXPORTING
      buffer        = iv_xstring
    IMPORTING
      output_length = lv_output_length
    TABLES
      binary_tab    = lt_binary_tab.

  CALL FUNCTION &apos;SCMS_BINARY_TO_STRING&apos;
    EXPORTING
      input_length  = lv_output_length
      encoding      = iv_encoding
    IMPORTING
      text_buffer   = rv_string
      output_length = lv_output_length
    TABLES
      binary_tab    = lt_binary_tab.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" VERSION="1" LANGU="E" DESCRIPT="Deserialize JSON to ABAP" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="LENGTH" VERSION="1" LANGU="E" DESCRIPT="Length of JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="FIELD_CACHE" VERSION="1" LANGU="E" DESCRIPT="Field Cache" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="T_T_FIELD_CACHE" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="OFFSET" VERSION="1" LANGU="E" DESCRIPT="Ofsset in JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
  <exception CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE" SCONAME="CX_SY_MOVE_CAST_ERROR" VERSION="1" LANGU="E" DESCRIPT="Superclass for All System Exceptions" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD restore.

  DATA: mark       LIKE offset,
        match      LIKE offset,
        pos        LIKE offset,
        unescape   TYPE abap_bool,
        ref_descr  TYPE REF TO cl_abap_refdescr,
        data_descr TYPE REF TO cl_abap_datadescr,
        data_ref   TYPE REF TO data,
        object_ref TYPE REF TO object,
        fields     LIKE field_cache,
        name_json  TYPE string.

  FIELD-SYMBOLS: &lt;value&gt;       TYPE any,
                 &lt;field_cache&gt; LIKE LINE OF field_cache.

  fields = field_cache.

  IF type_descr IS NOT INITIAL AND type_descr-&gt;kind EQ type_descr-&gt;kind_ref.
    ref_descr ?= type_descr.
    type_descr = ref_descr-&gt;get_referenced_type( ).
    IF ref_descr-&gt;type_kind EQ ref_descr-&gt;typekind_oref.
      IF data IS INITIAL.
        &quot; can fire an exception, if type is abstract or constructor protected
        CREATE OBJECT data TYPE (type_descr-&gt;absolute_name).
      ENDIF.
      object_ref ?= data.
      fields = get_fields( type_descr = type_descr object = object_ref ).
    ELSEIF ref_descr-&gt;type_kind EQ ref_descr-&gt;typekind_dref.
      IF data IS INITIAL.
        data_descr ?= type_descr.
        CREATE DATA data TYPE HANDLE data_descr.
      ENDIF.
      data_ref ?= data.
      ASSIGN data_ref-&gt;* TO &lt;value&gt;.
      fields = get_fields( type_descr = type_descr data = data_ref ).
      restore( EXPORTING json = json length = length type_descr = type_descr field_cache = fields
                 CHANGING data = &lt;value&gt; offset = offset ).
      RETURN.
    ENDIF.
  ENDIF.

  IF fields IS INITIAL AND type_descr IS NOT INITIAL AND type_descr-&gt;kind EQ type_descr-&gt;kind_struct.
    GET REFERENCE OF data INTO data_ref.
    fields = get_fields( type_descr = type_descr data = data_ref ).
  ENDIF.

  eat_white.
  eat_char `{`.
  eat_white.

  WHILE offset &lt; length AND json+offset(1) NE `}`.

    eat_white.
    eat_string name_json.
    eat_white.
    eat_char `:`.
    eat_white.

    READ TABLE fields WITH TABLE KEY name = name_json ASSIGNING &lt;field_cache&gt;.
    IF sy-subrc IS NOT INITIAL.
      TRANSLATE name_json TO UPPER CASE.
      READ TABLE fields WITH TABLE KEY name = name_json ASSIGNING &lt;field_cache&gt;.
    ENDIF.

    IF sy-subrc IS INITIAL.
      ASSIGN &lt;field_cache&gt;-value-&gt;* TO &lt;value&gt;.
      restore_type( EXPORTING json = json length = length type_descr = &lt;field_cache&gt;-type CHANGING data = &lt;value&gt; offset = offset ).
    ELSE.
      restore_type( EXPORTING json = json length = length CHANGING offset = offset ).
    ENDIF.

    eat_white.

    IF offset &lt; length AND json+offset(1) NE `}`.
      eat_char `,`.
    ELSE.
      EXIT.
    ENDIF.

  ENDWHILE.

  eat_char `}`.

ENDMETHOD.                    &quot;restore</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" VERSION="1" LANGU="E" DESCRIPT="Deserialize JSON to ABAP" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="JSON"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="LENGTH" VERSION="1" LANGU="E" DESCRIPT="Length of JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="FIELD_CACHE" VERSION="1" LANGU="E" DESCRIPT="Field Cache" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="T_T_FIELD_CACHE" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="OFFSET" VERSION="1" LANGU="E" DESCRIPT="Offset in JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
  <exception CLSNAME="/UI2/CL_JSON" CMPNAME="RESTORE_TYPE" SCONAME="CX_SY_MOVE_CAST_ERROR" VERSION="1" LANGU="E" DESCRIPT="Superclass for All System Exceptions" MTDTYPE="0" EDITORDER="3 "/>
  <source>METHOD restore_type.

  DATA: mark        LIKE offset,
        match       LIKE offset,
        unescape    TYPE abap_bool,
        sdummy      TYPE string,                            &quot;#EC NEEDED
        lr_idummy   TYPE REF TO i,                          &quot;#EC NEEDED
        lr_bdummy   TYPE REF TO bool,                       &quot;#EC NEEDED
        lr_sdummy   TYPE REF TO string,                     &quot;#EC NEEDED
        pos         LIKE offset,
        line        TYPE REF TO data,
        key_ref     TYPE REF TO data,
        data_ref    TYPE REF TO data,
        key_name    TYPE string,
        key_value   TYPE string,
        lt_fields   LIKE field_cache,
        lt_symbols  TYPE t_t_symbol,
        lv_ticks    TYPE string,
        lv_offset   TYPE string,
        lo_exp      TYPE REF TO cx_root,
        elem_descr  TYPE REF TO cl_abap_elemdescr,
        table_descr TYPE REF TO cl_abap_tabledescr,
        data_descr  TYPE REF TO cl_abap_datadescr.

  FIELD-SYMBOLS: &lt;line&gt;      TYPE any,
                 &lt;value&gt;     TYPE any,
                 &lt;data&gt;      TYPE data,
                 &lt;field&gt;     LIKE LINE OF lt_fields,
                 &lt;table&gt;     TYPE ANY TABLE,
                 &lt;value_sym&gt; LIKE LINE OF lt_symbols.

  IF type_descr IS INITIAL AND data IS SUPPLIED.
    type_descr = cl_abap_typedescr=&gt;describe_by_data( data ).
  ENDIF.

  eat_white.

  TRY .
      IF type_descr IS NOT INITIAL AND type_descr-&gt;absolute_name EQ mc_json_type.
        &quot; skip deserialization
        mark = offset.
        restore_type( EXPORTING json = json length = length CHANGING offset = offset ).
        match = offset - mark.
        data = json+mark(match).
      ENDIF.

      CASE json+offset(1).
        WHEN `{`. &quot; object
          IF type_descr IS NOT INITIAL.
            IF mv_assoc_arrays EQ c_bool-true AND type_descr-&gt;kind EQ cl_abap_typedescr=&gt;kind_table.
              table_descr ?= type_descr.
              data_descr = table_descr-&gt;get_table_line_type( ).
              IF table_descr-&gt;has_unique_key IS NOT INITIAL.
                eat_char `{`.
                eat_white.
                IF json+offset(1) NE `}`.
                  ASSIGN data TO &lt;table&gt;.
                  CLEAR &lt;table&gt;.
                  CREATE DATA line LIKE LINE OF &lt;table&gt;.
                  ASSIGN line-&gt;* TO &lt;line&gt;.
                  lt_fields = get_fields( type_descr = data_descr data = line ).
                  IF table_descr-&gt;key_defkind EQ table_descr-&gt;keydefkind_user AND lines( table_descr-&gt;key ) EQ 1.
                    READ TABLE table_descr-&gt;key INDEX 1 INTO key_name.
                    READ TABLE lt_fields WITH TABLE KEY name = key_name ASSIGNING &lt;field&gt;.
                    key_ref = &lt;field&gt;-value.
                    IF mv_assoc_arrays_opt EQ c_bool-true.
                      lt_symbols = get_symbols( type_descr = data_descr data = line ).
                      DELETE lt_symbols WHERE name EQ key_name.
                      IF lines( lt_symbols ) EQ 1.
                        READ TABLE lt_symbols INDEX 1 ASSIGNING &lt;value_sym&gt;.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                  WHILE offset &lt; length AND json+offset(1) NE `}`.
                    CLEAR &lt;line&gt;.
                    eat_white.
                    eat_string key_value.
                    eat_white.
                    eat_char `:`.
                    eat_white.
                    IF &lt;value_sym&gt; IS ASSIGNED.
                      ASSIGN &lt;value_sym&gt;-value-&gt;* TO &lt;value&gt;.
                      restore_type( EXPORTING json = json length = length type_descr = &lt;value_sym&gt;-type
                                    CHANGING data = &lt;value&gt; offset = offset ).
                    ELSE.
                      restore_type( EXPORTING json = json length = length type_descr = data_descr field_cache = lt_fields
                                    CHANGING data = &lt;line&gt; offset = offset ).
                    ENDIF.
                    IF table_descr-&gt;key_defkind EQ table_descr-&gt;keydefkind_user.
                      IF key_ref IS BOUND.
                        ASSIGN key_ref-&gt;* TO &lt;value&gt;.
                        IF &lt;value&gt; IS INITIAL.
                          MOVE key_value TO &lt;value&gt;.
                        ENDIF.
                      ENDIF.
                    ELSEIF &lt;line&gt; IS INITIAL.
                      MOVE key_value TO &lt;line&gt;.
                    ENDIF.

                    INSERT &lt;line&gt; INTO TABLE &lt;table&gt;.
                    eat_white.
                    IF offset &lt; length AND json+offset(1) NE `}`.
                      eat_char `,`.
                    ELSE.
                      EXIT.
                    ENDIF.
                  ENDWHILE.
                ELSE.
                  CLEAR data.
                ENDIF.
                eat_char `}`.
              ELSE.
                restore( EXPORTING json = json length = length CHANGING  offset = offset ).
              ENDIF.
            ELSEIF type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
              IF data IS INITIAL.
                generate_int_ex( EXPORTING json = json length = length CHANGING offset = offset data = data ).
              ELSE.
                data_ref ?= data.
                type_descr = cl_abap_typedescr=&gt;describe_by_data_ref( data_ref ).
                ASSIGN data_ref-&gt;* TO &lt;data&gt;.
                restore_type( EXPORTING json = json length = length type_descr = type_descr CHANGING data = &lt;data&gt; offset = offset ).
              ENDIF.
            ELSE.
              restore( EXPORTING json = json length = length type_descr = type_descr field_cache = field_cache
                       CHANGING data = data offset = offset ).
            ENDIF.
          ELSE.
            restore( EXPORTING json = json length = length CHANGING  offset = offset ).
          ENDIF.
        WHEN `[`. &quot; array
          IF type_descr IS NOT INITIAL AND type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
            IF data IS INITIAL.
              generate_int_ex( EXPORTING json = json length = length CHANGING offset = offset data = data ).
            ELSE.
              data_ref ?= data.
              type_descr = cl_abap_typedescr=&gt;describe_by_data_ref( data_ref ).
              ASSIGN data_ref-&gt;* TO &lt;data&gt;.
              restore_type( EXPORTING json = json length = length type_descr = type_descr CHANGING data = &lt;data&gt; offset = offset ).
            ENDIF.
          ELSE.
            eat_char `[`.
            eat_white.
            IF json+offset(1) NE `]`.
              IF type_descr IS NOT INITIAL AND type_descr-&gt;kind EQ cl_abap_typedescr=&gt;kind_table.
                table_descr ?= type_descr.
                data_descr = table_descr-&gt;get_table_line_type( ).
                ASSIGN data TO &lt;table&gt;.
                CLEAR &lt;table&gt;.
                CREATE DATA line LIKE LINE OF &lt;table&gt;.
                ASSIGN line-&gt;* TO &lt;line&gt;.
                lt_fields = get_fields( type_descr = data_descr data = line ).
                WHILE offset &lt; length AND json+offset(1) NE `]`.
                  CLEAR &lt;line&gt;.
                  restore_type( EXPORTING json = json length = length type_descr = data_descr field_cache = lt_fields
                                CHANGING data = &lt;line&gt; offset = offset ).
                  INSERT &lt;line&gt; INTO TABLE &lt;table&gt;.
                  eat_white.
                  IF offset &lt; length AND json+offset(1) NE `]`.
                    eat_char `,`.
                  ELSE.
                    EXIT.
                  ENDIF.
                ENDWHILE.
              ELSE.
                &quot; skip array
                WHILE offset &lt; length AND json+offset(1) NE `}`.
                  eat_white.
                  restore_type( EXPORTING json = json length = length CHANGING offset = offset ).
                  eat_white.
                  IF offset &lt; length AND json+offset(1) NE `]`.
                    eat_char `,`.
                  ELSE.
                    EXIT.
                  ENDIF.
                ENDWHILE.
                IF type_descr IS NOT INITIAL.
                  eat_char `]`.
                  throw_error.
                ENDIF.
              ENDIF.
            ELSE.
              CLEAR data.
            ENDIF.
            eat_char `]`.
          ENDIF.
        WHEN `&quot;`. &quot; string
          eat_string sdummy.
          IF type_descr IS NOT INITIAL.
            &quot; unescape string
            IF sdummy IS NOT INITIAL.
              IF type_descr-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
                elem_descr ?= type_descr.
                CASE elem_descr-&gt;type_kind.
                  WHEN cl_abap_typedescr=&gt;typekind_char.
                    IF elem_descr-&gt;output_length EQ 1 AND mc_bool_types CS elem_descr-&gt;absolute_name.
                      IF sdummy(1) CA `XxTt1`.
                        data = c_bool-true.
                      ELSE.
                        data = c_bool-false.
                      ENDIF.
                      RETURN.
                    ENDIF.
                  WHEN cl_abap_typedescr=&gt;typekind_xstring OR cl_abap_typedescr=&gt;typekind_hex.
                    string_to_xstring( EXPORTING in = sdummy CHANGING out = data ).
                    RETURN.
                  WHEN cl_abap_typedescr=&gt;typekind_date.
                    &quot; support for ISO8601 =&gt; https://en.wikipedia.org/wiki/ISO_8601
                    REPLACE FIRST OCCURRENCE OF REGEX `^(\d{4})-(\d{2})-(\d{2})` IN sdummy WITH `$1$2$3`
                    REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                    IF sy-subrc EQ 0.
                      sdummy = sdummy(match).
                    ELSE.
                      &quot; support for Edm.DateTime =&gt; http://www.odata.org/documentation/odata-version-2-0/json-format/
                      FIND FIRST OCCURRENCE OF REGEX `^\/Date\((-?\d+)([+-]\d{1,4})?\)\/` IN sdummy SUBMATCHES lv_ticks lv_offset IGNORING CASE.
                      IF sy-subrc EQ 0.
                        sdummy = edm_datetime_to_ts( ticks = lv_ticks offset = lv_offset typekind = elem_descr-&gt;type_kind ).
                      ELSE.
                        &quot; support for Edm.Time =&gt; https://www.w3.org/TR/xmlschema11-2/#nt-durationRep
                        REPLACE FIRST OCCURRENCE OF REGEX `^-?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)(?:\.(\d+))?S)?)?` IN sdummy WITH `$1$2$3`
                        REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                        IF sy-subrc EQ 0.
                          sdummy = sdummy(match).
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  WHEN cl_abap_typedescr=&gt;typekind_time.
                    &quot; support for ISO8601 =&gt; https://en.wikipedia.org/wiki/ISO_8601
                    REPLACE FIRST OCCURRENCE OF REGEX `^(\d{2}):(\d{2}):(\d{2})` IN sdummy WITH `$1$2$3`
                    REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                    IF sy-subrc EQ 0.
                      sdummy = sdummy(match).
                    ELSE.
                      &quot; support for Edm.DateTime =&gt; http://www.odata.org/documentation/odata-version-2-0/json-format/
                      FIND FIRST OCCURRENCE OF REGEX &apos;^\/Date\((-?\d+)([+-]\d{1,4})?\)\/&apos; IN sdummy SUBMATCHES lv_ticks lv_offset IGNORING CASE.
                      IF sy-subrc EQ 0.
                        sdummy = edm_datetime_to_ts( ticks = lv_ticks offset = lv_offset typekind = elem_descr-&gt;type_kind ).
                      ELSE.
                        &quot; support for Edm.Time =&gt; https://www.w3.org/TR/xmlschema11-2/#nt-durationRep
                        REPLACE FIRST OCCURRENCE OF REGEX `^-?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)(?:\.(\d+))?S)?)?` IN sdummy WITH `$4$5$6`
                        REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                        IF sy-subrc EQ 0.
                          sdummy = sdummy(match).
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  WHEN cl_abap_typedescr=&gt;typekind_packed.
                    REPLACE FIRST OCCURRENCE OF REGEX `^(\d{4})-?(\d{2})-?(\d{2})T(\d{2}):?(\d{2}):?(\d{2})(?:[\.,](\d{0,7}))?Z?` IN sdummy WITH `$1$2$3$4$5$6.$7`
                    REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                    IF sy-subrc EQ 0.
                      sdummy = sdummy(match).
                    ELSE.
                      FIND FIRST OCCURRENCE OF REGEX &apos;^\/Date\((-?\d+)([+-]\d{1,4})?\)\/&apos; IN sdummy SUBMATCHES lv_ticks lv_offset IGNORING CASE.
                      IF sy-subrc EQ 0.
                        sdummy = edm_datetime_to_ts( ticks = lv_ticks offset = lv_offset typekind = elem_descr-&gt;type_kind ).
                      ELSE.
                        &quot; support for Edm.Time =&gt; https://www.w3.org/TR/xmlschema11-2/#nt-durationRep
                        REPLACE FIRST OCCURRENCE OF REGEX `^-?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)(?:\.(\d+))?S)?)?` IN sdummy WITH `$1$2$3$4$5$6.$7`
                        REPLACEMENT LENGTH match.               &quot;#EC NOTEXT
                        IF sy-subrc EQ 0.
                          sdummy = sdummy(match).
                        ENDIF.
                      ENDIF.
                    ENDIF.
                ENDCASE.
              ELSEIF type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
                CREATE DATA lr_sdummy TYPE string.
                MOVE sdummy TO lr_sdummy-&gt;*.
                data ?= lr_sdummy.
                RETURN.
              ELSE.
                throw_error. &quot; Other wise dumps with OBJECTS_MOVE_NOT_SUPPORTED
              ENDIF.
              MOVE sdummy TO data.
            ELSEIF type_descr-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
              CLEAR data.
            ELSE.
              throw_error. &quot; Other wise dumps with OBJECTS_MOVE_NOT_SUPPORTED
            ENDIF.
          ENDIF.
        WHEN `-`. &quot; number
          IF type_descr IS NOT INITIAL.
            IF type_descr-&gt;kind EQ type_descr-&gt;kind_ref AND type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
              CREATE DATA lr_idummy TYPE i.
              eat_number lr_idummy-&gt;*.                      &quot;#EC NOTEXT
              data ?= lr_idummy.
            ELSEIF type_descr-&gt;kind EQ type_descr-&gt;kind_elem.
              eat_number data.                              &quot;#EC NOTEXT
            ELSE.
              eat_number sdummy.                            &quot;#EC NOTEXT
              throw_error.
            ENDIF.
          ELSE.
            eat_number sdummy.                              &quot;#EC NOTEXT
          ENDIF.
        WHEN OTHERS.
          FIND FIRST OCCURRENCE OF json+offset(1) IN `0123456789`.
          IF sy-subrc IS INITIAL. &quot; number
            IF type_descr IS NOT INITIAL.
              IF type_descr-&gt;kind EQ type_descr-&gt;kind_ref AND type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
                CREATE DATA lr_idummy TYPE i.
                eat_number lr_idummy-&gt;*.                    &quot;#EC NOTEXT
                data ?= lr_idummy.
              ELSEIF type_descr-&gt;kind EQ type_descr-&gt;kind_elem.
                eat_number data.                            &quot;#EC NOTEXT
              ELSE.
                eat_number sdummy.                          &quot;#EC NOTEXT
                throw_error.
              ENDIF.
            ELSE.
              eat_number sdummy.                            &quot;#EC NOTEXT
            ENDIF.
          ELSE. &quot; true/false/null
            IF type_descr IS NOT INITIAL.
              IF type_descr-&gt;kind EQ type_descr-&gt;kind_ref AND type_descr-&gt;type_kind EQ cl_abap_typedescr=&gt;typekind_dref.
                CREATE DATA lr_bdummy TYPE bool.
                eat_bool lr_bdummy-&gt;*.                      &quot;#EC NOTEXT
                data ?= lr_bdummy.
              ELSEIF type_descr-&gt;kind EQ type_descr-&gt;kind_elem.
                eat_bool data.                              &quot;#EC NOTEXT
              ELSE.
                eat_bool sdummy.                            &quot;#EC NOTEXT
                throw_error.
              ENDIF.
            ELSE.
              eat_bool sdummy.                              &quot;#EC NOTEXT
            ENDIF.
          ENDIF.
      ENDCASE.
    CATCH cx_sy_move_cast_error cx_sy_conversion_no_number cx_sy_conversion_overflow INTO lo_exp.
      CLEAR data.
      IF mv_strict_mode EQ abap_true.
        RAISE EXCEPTION TYPE cx_sy_move_cast_error EXPORTING previous = lo_exp.
      ENDIF.
  ENDTRY.

ENDMETHOD.                    &quot;restore_type</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" VERSION="1" LANGU="E" DESCRIPT="Serializes object" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="COMPRESS" VERSION="1" LANGU="E" DESCRIPT="Skip empty elements" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="NAME" VERSION="1" LANGU="E" DESCRIPT="Object name" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="PRETTY_NAME" VERSION="1" LANGU="E" DESCRIPT="Pretty Print property names" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PRETTY_NAME_MODE" PARVALUE="PRETTY_MODE-NONE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Data descriptor" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="ASSOC_ARRAYS" VERSION="1" LANGU="E" DESCRIPT="Serialize tables with unique keys as associative array" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="TS_AS_ISO8601" VERSION="1" LANGU="E" DESCRIPT="Dump timestamps as string in ISO8601 format" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="EXPAND_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="Expand named includes in structures" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-TRUE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="ASSOC_ARRAYS_OPT" VERSION="1" LANGU="E" DESCRIPT="Optimize rendering of name value maps" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="NUMC_AS_STRING" VERSION="1" LANGU="E" DESCRIPT="Serialize NUMC fields as strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="10 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOL" PARVALUE="C_BOOL-FALSE"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="NAME_MAPPINGS" VERSION="1" LANGU="E" DESCRIPT="ABAP&lt;-&gt;JSON Name Mapping Table" CMPTYPE="1" MTDTYPE="0" EDITORDER="11 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="NAME_MAPPINGS" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD serialize.

  &quot; **********************************************************************
  &quot;! Usage examples and documentation can be found on SCN:
  &quot; http://wiki.scn.sap.com/wiki/display/Snippets/One+more+ABAP+to+JSON+Serializer+and+Deserializer
  &quot; **********************************************************************  &quot;

  DATA: lo_json  TYPE REF TO /ui2/cl_json.

  CREATE OBJECT lo_json
    EXPORTING
      compress      = compress
      pretty_name   = pretty_name
      name_mappings     = name_mappings
      assoc_arrays      = assoc_arrays
      assoc_arrays_opt  = assoc_arrays_opt
      expand_includes   = expand_includes
      numc_as_string   = numc_as_string
      ts_as_iso8601    = ts_as_iso8601.

  r_json = lo_json-&gt;serialize_int( name = name data = data type_descr = type_descr ).

ENDMETHOD.                    &quot;serialize</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE_INT" VERSION="1" LANGU="E" DESCRIPT="Serializes ABAP object to JSON" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE_INT" SCONAME="DATA" VERSION="1" LANGU="E" DESCRIPT="Data to serialize" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE_INT" SCONAME="NAME" VERSION="1" LANGU="E" DESCRIPT="Object name" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE_INT" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Data descriptor" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="SERIALIZE_INT" SCONAME="R_JSON" VERSION="1" LANGU="E" DESCRIPT="JSON string" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="JSON"/>
  <source>METHOD serialize_int.

  &quot; **********************************************************************
  &quot;! Usage examples and documentation can be found on SCN:
  &quot; http://wiki.scn.sap.com/wiki/display/Snippets/One+more+ABAP+to+JSON+Serializer+and+Deserializer
  &quot; **********************************************************************  &quot;

  DATA: lo_descr   TYPE REF TO cl_abap_typedescr.

  IF type_descr IS INITIAL.
    lo_descr = cl_abap_typedescr=&gt;describe_by_data( data ).
  ELSE.
    lo_descr = type_descr.
  ENDIF.

  r_json = dump_int( data = data type_descr = lo_descr ).

  &quot; we do not do escaping of every single string value for white space characters,
  &quot; but we do it on top, to replace multiple calls by 3 only, while we do not serialize
  &quot; outlined/formatted JSON this shall not produce any harm
  REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;cr_lf          IN r_json WITH `\r\n`.
  REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;newline        IN r_json WITH `\n`.
  REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;horizontal_tab IN r_json WITH `\t`.
* REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;form_feed      IN r_json WITH `\f`.
* REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;backspace      IN r_json WITH `\b`.

  IF name IS NOT INITIAL AND ( mv_compress IS INITIAL OR r_json IS NOT INITIAL ).
    CONCATENATE `&quot;` name `&quot;:` r_json INTO r_json.
  ENDIF.

ENDMETHOD.                    &quot;serialize</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_RAW" VERSION="1" LANGU="E" DESCRIPT="Converts STRING to XSTRING" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_RAW" SCONAME="IV_STRING" VERSION="1" LANGU="E" DESCRIPT="Input data as STRING" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_RAW" SCONAME="IV_ENCODING" VERSION="1" LANGU="E" DESCRIPT="Encoding for conversion" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ENCODING" PAROPTIONL="X"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_RAW" SCONAME="RV_XSTRING" VERSION="1" LANGU="E" DESCRIPT="Converted XString" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSTRING"/>
  <source>METHOD string_to_raw.

  CALL FUNCTION &apos;SCMS_STRING_TO_XSTRING&apos;
    EXPORTING
      text   = iv_string
      encoding = iv_encoding
    IMPORTING
      buffer = rv_xstring
    EXCEPTIONS
      OTHERS = 1.

  IF sy-subrc IS NOT INITIAL.
    CLEAR rv_xstring.
  ENDIF.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_XSTRING" VERSION="1" LANGU="E" DESCRIPT="Converts XSTRING data to STRING" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_XSTRING" SCONAME="IN" VERSION="1" LANGU="E" DESCRIPT="String to convert to Xstring" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="STRING_TO_XSTRING" SCONAME="OUT" VERSION="1" LANGU="E" DESCRIPT="XString data" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD string_to_xstring.

  DATA: lv_xstring TYPE xstring.

  CALL FUNCTION &apos;SSFC_BASE64_DECODE&apos;
    EXPORTING
      b64data = in
    IMPORTING
      bindata = lv_xstring
    EXCEPTIONS
      OTHERS  = 1.

  IF sy-subrc IS INITIAL.
    MOVE lv_xstring TO out.
  ELSE.
    MOVE in TO out.
  ENDIF.

ENDMETHOD.                    &quot;string_to_xstring</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="TRIBOOL_TO_BOOL" VERSION="1" LANGU="E" DESCRIPT="Convertes 3 state bool to 2 state bool" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="TRIBOOL_TO_BOOL" SCONAME="IV_TRIBOOL" VERSION="1" LANGU="E" DESCRIPT="3 state boolean type (&apos;X&apos;-true, &apos;-&apos;-false, &apos;&apos;-undefined)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRIBOOL"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="TRIBOOL_TO_BOOL" SCONAME="RV_BOOL" VERSION="1" LANGU="E" DESCRIPT="2 state boolean type (&apos;X&apos; - true, &apos;&apos; - false)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="BOOL"/>
  <source>METHOD tribool_to_bool.
  IF iv_tribool EQ c_tribool-true.
    rv_bool = c_bool-true.
  ELSEIF iv_tribool EQ c_tribool-undefined.
    rv_bool = abap_undefined. &quot; fall back to abap_undefined
  ENDIF.
ENDMETHOD.                    &quot;TRIBOOL_TO_BOOL</source>
 </method>
 <method CLSNAME="/UI2/CL_JSON" CMPNAME="XSTRING_TO_STRING" VERSION="1" LANGU="E" DESCRIPT="Converts XSTRING data to STRING" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="XSTRING_TO_STRING" SCONAME="IN" VERSION="1" LANGU="E" DESCRIPT="XString to convert" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="/UI2/CL_JSON" CMPNAME="XSTRING_TO_STRING" SCONAME="OUT" VERSION="1" LANGU="E" DESCRIPT="String data" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD xstring_to_string.

  DATA: lv_xstring TYPE xstring.

  &quot; let us fix data conversion issues here
  lv_xstring = in.

  CALL FUNCTION &apos;SSFC_BASE64_ENCODE&apos;
    EXPORTING
      bindata = lv_xstring
    IMPORTING
      b64data = out
    EXCEPTIONS
      OTHERS  = 1.

  IF sy-subrc IS NOT INITIAL.
    MOVE in TO out.
  ENDIF.

ENDMETHOD.                    &quot;xstring_to_string</source>
 </method>
</CLAS>
